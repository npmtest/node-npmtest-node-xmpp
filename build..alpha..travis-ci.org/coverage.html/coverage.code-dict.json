{"/home/travis/build/npmtest/node-npmtest-node-xmpp/test.js":"/* istanbul instrument in package npmtest_node_xmpp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/lib.npmtest_node_xmpp.js":"/* istanbul instrument in package npmtest_node_xmpp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_xmpp = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_xmpp = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-xmpp && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_xmpp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_xmpp\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_xmpp.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_node_xmpp.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_xmpp.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_node_xmpp.__dirname +\n                    '/lib.npmtest_node_xmpp.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp/index.js":"'use strict'\n\nvar core = require('node-xmpp-core')\nvar client = require('node-xmpp-client')\nvar server = require('node-xmpp-server')\nvar component = require('node-xmpp-component')\n\nexports.Client = client\nexports.Component = component\nexports.server = server\n\ncore.exportCoreUtils(exports)\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-core/index.js":"'use strict'\n\nvar Connection = require('./lib/Connection')\nvar StreamParser = require('@xmpp/streamparser')\n\nvar JID = require('@xmpp/jid')\nvar xml = require('@xmpp/xml')\nvar inherits = require('inherits')\n\nexports.SRV = require('./lib/SRV')\n\nexports.exportCoreUtils = function (obj) {\n  // core\n  obj.Connection = Connection\n  obj.StreamParser = StreamParser\n\n  // jid\n  obj.JID = JID\n\n  // inherits\n  obj.inherits = inherits\n\n  // xml\n  obj.stanza = xml\n  obj.Stanza = xml.Stanza\n  obj.createStanza = xml.createStanza\n  obj.IQ = xml.IQ\n  obj.Presence = xml.Presence\n  obj.Message = xml.Message\n  obj.Parser = xml.Parser\n  obj.parse = xml.parse\n\n  // ltx\n  obj.ltx = xml.ltx\n  obj.createElement = xml.createElement\n  obj.Element = xml.Element\n  obj.escapeXML = xml.escapeXML\n  obj.escapeXMLText = xml.escapeXMLText\n}\n\nexports.exportCoreUtils(exports)\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-core/lib/Connection.js":"'use strict'\n\nvar net = require('net')\nvar EventEmitter = require('events').EventEmitter\nvar inherits = require('inherits')\nvar Element = require('@xmpp/xml').Element\nvar reconnect = require('reconnect-core')\nvar StreamParser = require('@xmpp/streamparser')\nvar starttls = require('node-xmpp-tls-connect')\nvar debug = require('debug')('xmpp:connection')\nvar assign = require('lodash.assign')\n\nvar NS_XMPP_TLS = 'urn:ietf:params:xml:ns:xmpp-tls'\nvar NS_STREAM = 'http://etherx.jabber.org/streams'\nvar NS_XMPP_STREAMS = 'urn:ietf:params:xml:ns:xmpp-streams'\n\nvar INITIAL_RECONNECT_DELAY = 1e3\nvar MAX_RECONNECT_DELAY = 30e3\n\nvar STREAM_OPEN = 'stream:stream'\nvar STREAM_CLOSE = '</stream:stream>'\n\nfunction defaultInjection (emitter, opts) {\n  // clone opts\n  var options = assign({}, opts)\n\n  // add computed options\n  options.initialDelay = (opts && (opts.initialReconnectDelay ||\n    opts.reconnectDelay)) || INITIAL_RECONNECT_DELAY\n  options.maxDelay = (opts && opts.maxReconnectDelay) || MAX_RECONNECT_DELAY\n  options.immediate = opts && opts.socket && (typeof opts.socket !== 'function')\n  options.type = opts && opts.delayType\n  options.emitter = emitter\n\n  // return calculated options\n  return options\n}\n\n/**\n Base class for connection-based streams (TCP).\n The socket parameter is optional for incoming connections.\n*/\nfunction Connection (opts) {\n  EventEmitter.call(this)\n\n  this.streamAttrs = (opts && opts.streamAttrs) || {}\n  this.xmlns = (opts && opts.xmlns) || {}\n  this.xmlns.stream = NS_STREAM\n\n  this.streamOpen = (opts && opts.streamOpen) || STREAM_OPEN\n  this.streamClose = (opts && opts.streamClose) || STREAM_CLOSE\n\n  this.rejectUnauthorized = !!(opts && opts.rejectUnauthorized)\n  this.serialized = !!(opts && opts.serialized)\n  this.requestCert = !!(opts && opts.requestCert)\n\n  this.servername = (opts && opts.servername)\n\n  this.boundOnData = this.onData.bind(this)\n  this.boundOnClose = this.onClose.bind(this)\n  this.boundEmitData = this.emit.bind(this, 'data')\n  this.boundEmitDrain = this.emit.bind(this, 'drain')\n\n  this._setupSocket(defaultInjection(this, opts))\n  this.once('reconnect', function () {\n    this.reconnect = opts && opts.reconnect\n  })\n}\n\ninherits(Connection, EventEmitter)\n\nConnection.prototype.NS_XMPP_TLS = NS_XMPP_TLS\nConnection.NS_STREAM = NS_STREAM\nConnection.prototype.NS_XMPP_STREAMS = NS_XMPP_STREAMS\n// Defaults\nConnection.prototype.allowTLS = true\n\nConnection.prototype._setupSocket = function (options) {\n  debug('setup socket')\n  var previousOptions = {}\n  var inject = reconnect(function (opts) {\n    var previousSocket = this.socket\n    /* if this opts.preserve is on\n     * the previous options are stored until next time.\n     * this is needed to restore from a setSecure call.\n     */\n    if (opts.preserve === 'on') {\n      opts.preserve = previousOptions\n      previousOptions = opts\n    } else if (opts.preserve) {\n      // switch back to the preversed options\n      opts = previousOptions = opts.preserve\n    } else {\n      // keep some state for eg SRV.connect\n      opts = previousOptions = opts || previousOptions\n    }\n\n    if (typeof opts.socket === 'function') {\n      debug('use lazy socket')\n      /* lazy evaluation\n       * (can be retriggered by calling connection.connect()\n       *  without arguments after a previous\n       *  connection.connect({socket:function() { â€¦ }})) */\n      this.socket = opts.socket.call(this)\n    } else {\n      debug('use standard socket')\n      // only use this socket once\n      this.socket = opts.socket\n      opts.socket = null\n      if (this.socket) {\n        this.once('connect', function () {\n          inject.options.immediate = false\n        })\n      }\n    }\n    this.socket = this.socket || new net.Socket()\n    if (previousSocket !== this.socket) {\n      this.setupStream()\n    }\n    return this.socket\n  }.bind(this))\n\n  inject(inject.options = options)\n\n  // wrap the end function provided by reconnect-core to trigger the stream end logic\n  var end = this.end\n  this.end = this.disconnect = function () {\n    this.closeStream()\n    end()\n  }\n\n  this.on('connection', function () {\n    if (!this.parser) this.startParser()\n  })\n  this.on('end', function () {\n    previousOptions = {}\n  })\n}\n\n/**\n Used by both the constructor and by reinitialization in setSecure().\n*/\nConnection.prototype.setupStream = function () {\n  debug('setup stream')\n  this.socket.on('end', this.onEnd.bind(this))\n  this.socket.on('data', this.boundOnData)\n  this.socket.on('close', this.boundOnClose)\n  // let them sniff unparsed XML\n  this.socket.on('data', this.boundEmitData)\n  this.socket.on('drain', this.boundEmitDrain)\n  // ignore errors after disconnect\n  this.socket.on('error', function () {})\n\n  if (!this.socket.serializeStanza) {\n    /**\n    * This is optimized for continuous TCP streams. If your \"socket\"\n    * actually transports frames (WebSockets) and you can't have\n    * stanzas split across those, use:\n    *     cb(el.toString())\n    */\n    if (this.serialized) {\n      this.socket.serializeStanza = function (el, cb) {\n        // Continuously write out\n        el.write(function (s) {\n          cb(s)\n        })\n      }\n    } else {\n      this.socket.serializeStanza = function (el, cb) {\n        cb(el.toString())\n      }\n    }\n  }\n}\n\nConnection.prototype.pause = function () {\n  if (this.socket.pause) this.socket.pause()\n}\n\nConnection.prototype.resume = function () {\n  if (this.socket.resume) this.socket.resume()\n}\n\n/** Climbs the stanza up if a child was passed,\n    but you can send strings and buffers too.\n\n    Returns whether the socket flushed data.\n*/\nConnection.prototype.send = function (stanza) {\n  if (!this.socket || !this.streamOpened) return\n\n  if (!this.socket.writable) {\n    this.socket.end()\n    return\n  }\n\n  debug('send: ' + stanza.toString())\n\n  var flushed = true\n\n  if (stanza.root) {\n    var el = this.rmXmlns(stanza.root())\n    this.socket.serializeStanza(el, function (s) {\n      flushed = this.write(s)\n    }.bind(this.socket))\n  } else {\n    flushed = this.socket.write(stanza)\n  }\n  return flushed\n}\n\nConnection.prototype.startParser = function () {\n  var self = this\n  this.parser = new StreamParser(this.maxStanzaSize)\n\n  this.parser.on('streamStart', function (attrs) {\n    /* We need those xmlns often, store them extra */\n    self.streamNsAttrs = {}\n    for (var k in attrs) {\n      if (k === 'xmlns' || (k.substr(0, 6) === 'xmlns:')) {\n        self.streamNsAttrs[k] = attrs[k]\n      }\n    }\n\n    /* Notify in case we don't wait for <stream:features/>\n       (Component or non-1.0 streams)\n     */\n    self.emit('streamStart', attrs)\n  })\n  this.parser.on('stanza', function (stanza) {\n    self.onStanza(self.addStreamNs(stanza))\n  })\n  this.parser.on('error', function (e) {\n    self.error(e.condition || 'internal-server-error', e.message)\n  })\n  this.parser.once('end', function () {\n    self.stopParser()\n    if (self.reconnect) {\n      self.once('reconnect', self.startParser.bind(self))\n    } else {\n      self.end()\n    }\n  })\n}\n\nConnection.prototype.stopParser = function () {\n  /* No more events, please (may happen however) */\n  if (this.parser) {\n    var parser = this.parser\n    /* Get GC'ed */\n    this.parser = null\n    parser.end()\n  }\n}\n\n/**\n * http://xmpp.org/rfcs/rfc6120.html#streams-open\n */\nConnection.prototype.openStream = function () {\n  var attrs = {}\n  for (var k in this.xmlns) {\n    if (this.xmlns.hasOwnProperty(k)) {\n      if (!k) {\n        attrs.xmlns = this.xmlns[k]\n      } else {\n        attrs['xmlns:' + k] = this.xmlns[k]\n      }\n    }\n  }\n  for (k in this.streamAttrs) {\n    if (this.streamAttrs.hasOwnProperty(k)) {\n      attrs[k] = this.streamAttrs[k]\n    }\n  }\n\n  if (this.streamTo) { // in case of a component connecting\n    attrs.to = this.streamTo\n  }\n\n  var el = new Element(this.streamOpen, attrs)\n  var streamOpen\n  if (el.name === 'stream:stream') {\n    // make it non-empty to cut the closing tag\n    el.t(' ')\n    var s = el.toString()\n    streamOpen = s.substr(0, s.indexOf(' </stream:stream>'))\n  } else {\n    streamOpen = el.toString()\n  }\n\n  this.streamOpened = true\n  this.send(streamOpen)\n}\n// FIXME deprecate\nConnection.prototype.startStream = Connection.prototype.openStream\n\n/**\n * http://xmpp.org/rfcs/rfc6120.html#streams-close\n */\nConnection.prototype.closeStream = function () {\n  this.send(this.streamClose)\n  this.streamOpened = false\n}\n// FIXME deprecate\nConnection.prototype.endStream = Connection.prototype.closeStream\n\nConnection.prototype.onData = function (data) {\n  debug('receive: ' + data.toString('utf8'))\n  if (this.parser) {\n    this.parser.write(data)\n  }\n}\n\nConnection.prototype.setSecure = function (credentials, isServer, servername) {\n  // Remove old event listeners\n  this.socket.removeListener('data', this.boundOnData)\n  this.socket.removeListener('data', this.boundEmitData)\n\n  // retain socket 'end' listeners because ssl layer doesn't support it\n  this.socket.removeListener('drain', this.boundEmitDrain)\n  this.socket.removeListener('close', this.boundOnClose)\n  // remove idle_timeout\n  if (this.socket.clearTimer) {\n    this.socket.clearTimer()\n  }\n\n  var cleartext = starttls({\n    socket: this.socket,\n    rejectUnauthorized: this.rejectUnauthorized,\n    credentials: credentials || this.credentials,\n    requestCert: this.requestCert,\n    isServer: !!isServer,\n    servername: isServer && servername\n  }, function () {\n    this.isSecure = true\n    this.once('disconnect', function () {\n      this.isSecure = false\n    })\n    cleartext.emit('connect', cleartext)\n  }.bind(this))\n  cleartext.on('clientError', this.emit.bind(this, 'error'))\n  if (!this.reconnect) {\n    this.reconnect = true // need this so stopParser works properly\n    this.once('reconnect', function () { this.reconnect = false })\n  }\n  this.stopParser()\n  // if we reconnect we need to get back to the previous socket creation\n  this.listen({ socket: cleartext, preserve: 'on' })\n}\n\nfunction getAllText (el) {\n  return !el.children ? el : el.children.reduce(function (text, child) {\n    return text + getAllText(child)\n  }, '')\n}\n\n/**\n * This is not an event listener, but takes care of the TLS handshake\n * before 'stanza' events are emitted to the derived classes.\n */\nConnection.prototype.onStanza = function (stanza) {\n  if (stanza.is('error', NS_STREAM)) {\n    var error = new Error('' + getAllText(stanza))\n    error.stanza = stanza\n    this.socket.emit('error', error)\n  } else if (stanza.is('features', this.NS_STREAM) &&\n    this.allowTLS &&\n    !this.isSecure &&\n    stanza.getChild('starttls', this.NS_XMPP_TLS)) {\n    /* Signal willingness to perform TLS handshake */\n    this.send(new Element('starttls', { xmlns: this.NS_XMPP_TLS }))\n  } else if (this.allowTLS &&\n    stanza.is('proceed', this.NS_XMPP_TLS)) {\n    /* Server is waiting for TLS handshake */\n    this.setSecure()\n  } else {\n    this.emit('stanza', stanza)\n  }\n}\n\n/**\n * Add stream xmlns to a stanza\n *\n * Does not add our default xmlns as it is different for\n * C2S/S2S/Component connections.\n */\nConnection.prototype.addStreamNs = function (stanza) {\n  for (var attr in this.streamNsAttrs) {\n    if (!stanza.attrs[attr] &&\n      !((attr === 'xmlns') && (this.streamNsAttrs[attr] === this.xmlns['']))\n    ) {\n      stanza.attrs[attr] = this.streamNsAttrs[attr]\n    }\n  }\n  return stanza\n}\n\n/**\n * Remove superfluous xmlns that were aleady declared in\n * our <stream:stream>\n */\nConnection.prototype.rmXmlns = function (stanza) {\n  for (var prefix in this.xmlns) {\n    var attr = prefix ? 'xmlns:' + prefix : 'xmlns'\n    if (stanza.attrs[attr] === this.xmlns[prefix]) {\n      stanza.attrs[attr] = null\n    }\n  }\n  return stanza\n}\n\n/**\n * XMPP-style end connection for user\n */\nConnection.prototype.onEnd = function () {\n  this.closeStream()\n  if (!this.reconnect) {\n    this.emit('end')\n  }\n}\n\nConnection.prototype.onClose = function () {\n  if (!this.reconnect) {\n    this.emit('close')\n  }\n}\n\n/**\n * End connection with stream error.\n * Emits 'error' event too.\n *\n * @param {String} condition XMPP error condition, see RFC3920 4.7.3. Defined Conditions\n * @param {String} text Optional error message\n */\nConnection.prototype.error = function (condition, message) {\n  this.emit('error', new Error(message))\n\n  if (!this.socket || !this.socket.writable) return\n\n  /* RFC 3920, 4.7.1 stream-level errors rules */\n  if (!this.streamOpened) this.openStream()\n\n  var error = new Element('stream:error')\n  error.c(condition, { xmlns: NS_XMPP_STREAMS })\n  if (message) {\n    error.c('text', {\n      xmlns: NS_XMPP_STREAMS,\n      'xml:lang': 'en'\n    }).t(message)\n  }\n\n  this.send(error)\n  this.end()\n}\n\nmodule.exports = Connection\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-tls-connect/starttls.js":"'use strict';\n\nmodule.exports = connect;\nconnect.connect = connect;\n\n/* this whole file only exists because tls.start\n * doens't exists and tls.connect cannot start server\n * connections\n *\n * copied from _tls_wrap.js\n */\n\n// Target API:\n//\n//  var s = require('net').createStream(25, 'smtp.example.com')\n//  s.on('connect', function() {\n//   require('tls-connect')(s, {credentials:creds, isServer:false}, function() {\n//      if (!s.authorized) {\n//        s.destroy()\n//        return\n//      }\n//\n//      s.end(\"hello world\\n\")\n//    })\n//  })\n\nvar net = require('net')\nvar tls = require('tls')\nvar util = require('util')\nvar assert = require('assert')\nvar crypto = require('crypto')\n\nvar createSecureContext = tls.createSecureContext || crypto.createCredentials\n\n// Returns an array [options] or [options, cb]\n// It is the same as the argument of Socket.prototype.connect().\nfunction __normalizeConnectArgs(args) {\n  var options = {};\n\n  if (typeof(args[0]) == 'object') {\n    // connect(options, [cb])\n    options = args[0];\n  } else if (isPipeName(args[0])) {\n    // connect(path, [cb]);\n    options.path = args[0];\n  } else {\n    // connect(port, [host], [cb])\n    options.port = args[0];\n    if (typeof(args[1]) === 'string') {\n      options.host = args[1];\n    }\n  }\n\n  var cb = args[args.length - 1];\n  return typeof(cb) === 'function' ? [options, cb] : [options];\n}\n\nfunction __checkServerIdentity(host, cert) {\n  // Create regexp to much hostnames\n  function regexpify(host, wildcards) {\n    // Add trailing dot (make hostnames uniform)\n    if (!/\\.$/.test(host)) host += '.';\n\n    // The same applies to hostname with more than one wildcard,\n    // if hostname has wildcard when wildcards are not allowed,\n    // or if there are less than two dots after wildcard (i.e. *.com or *d.com)\n    //\n    // also\n    //\n    // \"The client SHOULD NOT attempt to match a presented identifier in\n    // which the wildcard character comprises a label other than the\n    // left-most label (e.g., do not match bar.*.example.net).\"\n    // RFC6125\n    if (!wildcards && /\\*/.test(host) || /[\\.\\*].*\\*/.test(host) ||\n        /\\*/.test(host) && !/\\*.*\\..+\\..+/.test(host)) {\n      return /$./;\n    }\n\n    // Replace wildcard chars with regexp's wildcard and\n    // escape all characters that have special meaning in regexps\n    // (i.e. '.', '[', '{', '*', and others)\n    var re = host.replace(\n        /\\*([a-z0-9\\\\-_\\.])|[\\.,\\-\\\\\\^\\$+?*\\[\\]\\(\\):!\\|{}]/g,\n        function(all, sub) {\n          if (sub) return '[a-z0-9\\\\-_]*' + (sub === '-' ? '\\\\-' : sub);\n          return '\\\\' + all;\n        });\n\n    return new RegExp('^' + re + '$', 'i');\n  }\n\n  var dnsNames = [],\n      uriNames = [],\n      ips = [],\n      matchCN = true,\n      valid = false;\n\n  // There're several names to perform check against:\n  // CN and altnames in certificate extension\n  // (DNS names, IP addresses, and URIs)\n  //\n  // Walk through altnames and generate lists of those names\n  if (cert.subjectaltname) {\n    cert.subjectaltname.split(/, /g).forEach(function(altname) {\n      if (/^DNS:/.test(altname)) {\n        dnsNames.push(altname.slice(4));\n      } else if (/^IP Address:/.test(altname)) {\n        ips.push(altname.slice(11));\n      } else if (/^URI:/.test(altname)) {\n        var uri = url.parse(altname.slice(4));\n        if (uri) uriNames.push(uri.hostname);\n      }\n    });\n  }\n\n  // If hostname is an IP address, it should be present in the list of IP\n  // addresses.\n  if (net.isIP(host)) {\n    valid = ips.some(function(ip) {\n      return ip === host;\n    });\n  } else {\n    // Transform hostname to canonical form\n    if (!/\\.$/.test(host)) host += '.';\n\n    // Otherwise check all DNS/URI records from certificate\n    // (with allowed wildcards)\n    dnsNames = dnsNames.map(function(name) {\n      return regexpify(name, true);\n    });\n\n    // Wildcards ain't allowed in URI names\n    uriNames = uriNames.map(function(name) {\n      return regexpify(name, false);\n    });\n\n    dnsNames = dnsNames.concat(uriNames);\n\n    if (dnsNames.length > 0) matchCN = false;\n\n\n    // Match against Common Name (CN) only if no supported identifiers are\n    // present.\n    //\n    // \"As noted, a client MUST NOT seek a match for a reference identifier\n    //  of CN-ID if the presented identifiers include a DNS-ID, SRV-ID,\n    //  URI-ID, or any application-specific identifier types supported by the\n    //  client.\"\n    // RFC6125\n    if (matchCN) {\n      var commonNames = cert.subject.CN;\n      if (util.isArray(commonNames)) {\n        for (var i = 0, k = commonNames.length; i < k; ++i) {\n          dnsNames.push(regexpify(commonNames[i], true));\n        }\n      } else {\n        dnsNames.push(regexpify(commonNames, true));\n      }\n    }\n\n    valid = dnsNames.some(function(re) {\n      return re.test(host);\n    });\n  }\n\n  return valid;\n};\n\n// Target API:\n//\n//  var s = tls.connect({port: 8000, host: \"google.com\"}, function() {\n//    if (!s.authorized) {\n//      s.destroy();\n//      return;\n//    }\n//\n//    // s.socket;\n//\n//    s.end(\"hello world\\n\");\n//  });\n//\n//\nfunction normalizeConnectArgs(listArgs) {\n  var args = __normalizeConnectArgs(listArgs);\n  var options = args[0];\n  var cb = args[1];\n\n  if (typeof(listArgs[1]) === 'object') {\n    options = util._extend(options, listArgs[1]);\n  } else if (typeof(listArgs[2]) === 'object') {\n    options = util._extend(options, listArgs[2]);\n  }\n\n  return (cb) ? [options, cb] : [options];\n}\n\nfunction legacyConnect(hostname, options, NPN, credentials) {\n  assert(options.socket);\n  var pair = tls.createSecurePair(credentials,\n                                  !!options.isServer,\n                                  !!options.requestCert,\n                                  !!options.rejectUnauthorized,\n                                  {\n                                    NPNProtocols: NPN.NPNProtocols,\n                                    servername: hostname\n                                  });\n  legacyPipe(pair, options.socket);\n  pair.cleartext._controlReleased = true;\n  pair.on('error', function(err) {\n    pair.cleartext.emit('error', err);\n  });\n\n  return pair;\n}\n\nfunction connect(/* [port, host], options, cb */) {\n  var args = normalizeConnectArgs(arguments);\n  var options = args[0];\n  var cb = args[1];\n\n  var defaults = {\n    rejectUnauthorized: '0' !== process.env.NODE_TLS_REJECT_UNAUTHORIZED,\n    requestCert: true,\n    isServer: false\n  };\n  options = util._extend(defaults, options || {});\n\n  var hostname = options.servername ||\n                 options.host ||\n                 options.socket && options.socket._host ||\n                 '127.0.0.1',\n      NPN = {},\n      // createCredentials() is deprecated, use tls.createSecureContext instead\n      // https://github.com/dodo/node-tls-connect/issues/2\n      credentials = options.credentials || createSecureContext(options);\n\n  if (tls.convertNPNProtocols)\n    tls.convertNPNProtocols(options.NPNProtocols, NPN);\n\n  // Wrapping TLS socket inside another TLS socket was requested -\n  // create legacy secure pair\n  var socket;\n  var legacy;\n  var result;\n  if (typeof tls.TLSSocket === 'undefined') {\n    legacy = true;\n    socket = legacyConnect(hostname, options, NPN, credentials);\n    result = socket.cleartext;\n  } else {\n    legacy = false;\n    socket = new tls.TLSSocket(options.socket, {\n      credentials: credentials,\n      isServer: !!options.isServer,\n      requestCert: !!options.requestCert,\n      rejectUnauthorized: !!options.rejectUnauthorized,\n      NPNProtocols: NPN.NPNProtocols\n    });\n    result = socket;\n  }\n\n  if (socket._handle && !socket._connecting) {\n    onHandle();\n  } else {\n    // Not even started connecting yet (or probably resolving dns address),\n    // catch socket errors and assign handle.\n    if (!legacy && options.socket) {\n      options.socket.once('connect', function() {\n        assert(options.socket._handle);\n        socket._handle = options.socket._handle;\n        socket._handle.owner = socket;\n\n        socket.emit('connect');\n      });\n    }\n    socket.once('connect', onHandle);\n  }\n\n  if (cb)\n    result.once('secureConnect', cb);\n\n  if (!options.socket) {\n    assert(!legacy);\n    var connect_opt;\n    if (options.path && !options.port) {\n      connect_opt = { path: options.path };\n    } else {\n      connect_opt = {\n        port: options.port,\n        host: options.host,\n        localAddress: options.localAddress\n      };\n    }\n    socket.connect(connect_opt);\n  }\n\n  return result;\n\n  function onHandle() {\n    if (!legacy)\n      socket._releaseControl();\n\n    if (options.session)\n      socket.setSession(options.session);\n\n    if (!legacy) {\n      if (options.servername)\n        socket.setServername(options.servername);\n\n      if (!options.isServer)\n        socket._start();\n    }\n    socket.on('secure', function() {\n      var ssl = socket._ssl || socket.ssl;\n      var verifyError = ssl.verifyError();\n\n      // Verify that server's identity matches it's certificate's names\n      if (!verifyError) {\n        var cert = result.getPeerCertificate();\n        var validCert = __checkServerIdentity(hostname, cert);\n        if (!validCert) {\n          verifyError = new Error('Hostname/IP doesn\\'t match certificate\\'s ' +\n                                  'altnames');\n        }\n      }\n\n      if (verifyError) {\n        result.authorized = false;\n        result.authorizationError = verifyError.message;\n\n        if (options.rejectUnauthorized) {\n          result.emit('error', verifyError);\n          result.destroy();\n          return;\n        } else {\n          result.emit('secureConnect');\n        }\n      } else {\n        result.authorized = true;\n        result.emit('secureConnect');\n      }\n\n      // Uncork incoming data\n      result.removeListener('end', onHangUp);\n    });\n\n    function onHangUp() {\n      // NOTE: This logic is shared with _http_client.js\n      if (!socket._hadError) {\n        socket._hadError = true;\n        var error = new Error('socket hang up');\n        error.code = 'ECONNRESET';\n        socket.destroy();\n        socket.emit('error', error);\n      }\n    }\n    result.once('end', onHangUp);\n  }\n};\n\nfunction legacyPipe(pair, socket) {\n  pair.encrypted.pipe(socket);\n  socket.pipe(pair.encrypted);\n\n  pair.encrypted.on('close', function() {\n    process.nextTick(function() {\n      // Encrypted should be unpiped from socket to prevent possible\n      // write after destroy.\n      if (pair.encrypted.unpipe)\n        pair.encrypted.unpipe(socket);\n      socket.destroySoon();\n    });\n  });\n\n  pair.fd = socket.fd;\n  pair._handle = socket._handle;\n  var cleartext = pair.cleartext;\n  cleartext.socket = socket;\n  cleartext.encrypted = pair.encrypted;\n  cleartext.authorized = false;\n\n  // cycle the data whenever the socket drains, so that\n  // we can pull some more into it.  normally this would\n  // be handled by the fact that pipe() triggers read() calls\n  // on writable.drain, but CryptoStreams are a bit more\n  // complicated.  Since the encrypted side actually gets\n  // its data from the cleartext side, we have to give it a\n  // light kick to get in motion again.\n  socket.on('drain', function() {\n    if (pair.encrypted._pending && pair.encrypted._writePending)\n      pair.encrypted._writePending();\n    if (pair.cleartext._pending && pair.cleartext._writePending)\n      pair.cleartext._writePending();\n    if (pair.encrypted.read)\n      pair.encrypted.read(0);\n    if (pair.cleartext.read)\n      pair.cleartext.read(0);\n  });\n\n  function onerror(e) {\n    if (cleartext._controlReleased) {\n      cleartext.emit('error', e);\n    }\n  }\n\n  function onclose() {\n    socket.removeListener('error', onerror);\n    socket.removeListener('timeout', ontimeout);\n  }\n\n  function ontimeout() {\n    cleartext.emit('timeout');\n  }\n\n  socket.on('error', onerror);\n  socket.on('close', onclose);\n  socket.on('timeout', ontimeout);\n\n  return cleartext;\n};\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-core/lib/SRV.js":"'use strict'\n\nvar dns = require('dns')\n\nfunction compareNumbers (a, b) {\n  a = parseInt(a, 10)\n  b = parseInt(b, 10)\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\nfunction groupSrvRecords (addrs) {\n  var groups = {} // by priority\n  addrs.forEach(function (addr) {\n    if (!groups.hasOwnProperty(addr.priority)) {\n      groups[addr.priority] = []\n    }\n\n    groups[addr.priority].push(addr)\n  })\n\n  var result = []\n  Object.keys(groups).sort(compareNumbers).forEach(function (priority) {\n    var group = groups[priority]\n    var totalWeight = 0\n    group.forEach(function (addr) {\n      totalWeight += addr.weight\n    })\n    var w = Math.floor(Math.random() * totalWeight)\n    totalWeight = 0\n    var candidate = group[0]\n    group.forEach(function (addr) {\n      totalWeight += addr.weight\n      if (w < totalWeight) {\n        candidate = addr\n      }\n    })\n    if (candidate) {\n      result.push(candidate)\n    }\n  })\n  return result\n}\n\nfunction resolveSrv (name, cb) {\n  dns.resolveSrv(name, function (err, addrs) {\n    if (err) {\n      /* no SRV record, try domain as A */\n      cb(err)\n    } else {\n      var pending = 0\n      var error\n      var results = []\n      var cb1 = function (e, addrs1) {\n        error = error || e\n        results = results.concat(addrs1)\n        pending--\n        if (pending < 1) {\n          cb(results ? null : error, results)\n        }\n      }\n      var gSRV = groupSrvRecords(addrs)\n      pending = gSRV.length\n      gSRV.forEach(function (addr) {\n        resolveHost(addr.name, function (e, a) {\n          if (a) {\n            a = a.map(function (a1) {\n              return { name: a1, port: addr.port }\n            })\n          }\n          cb1(e, a)\n        })\n      })\n    }\n  })\n}\n\n// one of both A & AAAA, in case of broken tunnels\nfunction resolveHost (name, cb) {\n  var error\n  var results = []\n  var cb1 = function (e, addr) {\n    error = error || e\n    if (addr) {\n      results.push(addr)\n    }\n\n    cb((results.length > 0) ? null : error, results)\n  }\n\n  dns.lookup(name, cb1)\n}\n\n// connection attempts to multiple addresses in a row\nfunction tryConnect (connection, addrs) {\n  connection.on('connect', cleanup)\n  connection.on('disconnect', connectNext)\n  return connectNext()\n\n  function cleanup () {\n    connection.removeListener('connect', cleanup)\n    connection.removeListener('disconnect', connectNext)\n  }\n\n  function connectNext () {\n    var addr = addrs.shift()\n    if (addr) {\n      connection.socket.connect(addr.port, addr.name)\n    } else {\n      cleanup()\n    }\n  }\n}\n\n// returns a lazy iterator which can be restarted via connection.connect()\nexports.connect = function connect (opts) {\n  var services = opts.services.slice()\n  // lazy evaluation to determine endpoint\n  function tryServices (retry) {\n    var connection = this\n    if (!connection.socket && opts.socket) {\n      if (typeof opts.socket === 'function') {\n        connection.socket = opts.socket.call(this)\n      } else {\n        connection.socket = opts.socket\n      }\n      opts.socket = null\n    } else if (!retry) {\n      connection.socket = null\n    }\n    var service = services.shift()\n    if (service) {\n      resolveSrv(service + '.' + opts.domain, function (error, addrs) {\n        if (!error && addrs) {\n          tryConnect(connection, addrs)\n        // call tryServices again\n        } else {\n          tryServices.call(connection, 'retry')\n        }\n      })\n    } else {\n      resolveHost(opts.domain, function (error, addrs) {\n        if (addrs && addrs.length > 0) {\n          addrs = addrs.map(function (addr) {\n            return {\n              name: addr,\n              port: opts.defaultPort\n            }\n          })\n          tryConnect(connection, addrs)\n        } else if (connection.reconnect) {\n          // retry from the beginning\n          services = opts.services.slice()\n          // get a new socket\n          connection.socket = null\n        } else {\n          error = error || new Error('No addresses resolved for ' +\n              opts.domain)\n          connection.emit('error', error)\n        }\n      })\n    }\n    return connection.socket\n  }\n  return tryServices\n}\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-client/index.js":"'use strict'\n\nvar Client = require('./lib/Client')\nvar SASL = require('./lib/sasl')\nvar core = require('node-xmpp-core')\n\nmodule.exports = Client\nmodule.exports.Client = Client\nmodule.exports.SASL = SASL\n\ncore.exportCoreUtils(module.exports)\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-client/lib/Client.js":"'use strict'\n\nvar Session = require('./session')\nvar core = require('node-xmpp-core')\nvar JID = core.JID\nvar Stanza = core.Stanza\nvar Element = core.Element\nvar inherits = core.inherits\nvar sasl = require('./sasl')\nvar Anonymous = require('./authentication/anonymous')\nvar Plain = require('./authentication/plain')\nvar DigestMD5 = require('./authentication/digestmd5')\nvar XOAuth2 = require('./authentication/xoauth2')\nvar External = require('./authentication/external')\nvar exec = require('child_process').exec\nvar debug = require('debug')('xmpp:client')\nvar path = require('path')\n\nvar NS_CLIENT = 'jabber:client'\nvar NS_REGISTER = 'jabber:iq:register'\nvar NS_XMPP_SASL = 'urn:ietf:params:xml:ns:xmpp-sasl'\nvar NS_XMPP_BIND = 'urn:ietf:params:xml:ns:xmpp-bind'\nvar NS_XMPP_SESSION = 'urn:ietf:params:xml:ns:xmpp-session'\n\nvar STATE_PREAUTH = 0\nvar STATE_AUTH = 1\nvar STATE_AUTHED = 2\nvar STATE_BIND = 3\nvar STATE_SESSION = 4\nvar STATE_ONLINE = 5\n\nvar IQID_SESSION = 'sess'\nvar IQID_BIND = 'bind'\n\nvar decode64, encode64, Buffer\nif (typeof btoa === 'undefined') {\n  var btoa = null\n  var atob = null\n}\n\nif (typeof btoa === 'function') {\n  decode64 = function (encoded) {\n    return atob(encoded)\n  }\n} else {\n  Buffer = require('buffer').Buffer\n  decode64 = function (encoded) {\n    return (new Buffer(encoded, 'base64')).toString('utf8')\n  }\n}\nif (typeof atob === 'function') {\n  encode64 = function (decoded) {\n    return btoa(decoded)\n  }\n} else {\n  Buffer = require('buffer').Buffer\n  encode64 = function (decoded) {\n    return (new Buffer(decoded, 'utf8')).toString('base64')\n  }\n}\n\n/**\n * params object:\n *   jid: String (required)\n *   password: String (required)\n *   host: String (optional)\n *   port: Number (optional)\n *   reconnect: Boolean (optional)\n *   autostart: Boolean (optional) - if we start connecting to a given port\n *   register: Boolean (option) - register account before authentication\n *   legacySSL: Boolean (optional) - connect to the legacy SSL port, requires at least the host to be specified\n *   credentials: Dictionary (optional) - TLS or SSL key and certificate credentials\n *   actAs: String (optional) - if admin user act on behalf of another user (just user)\n *   disallowTLS: Boolean (optional) - prevent upgrading the connection to a secure one via TLS\n *   preferred: String (optional) - Preferred SASL mechanism to use\n *   bosh.url: String (optional) - BOSH endpoint to use\n *   bosh.prebind: Function(error, data) (optional) - Just prebind a new BOSH session for browser client use\n *            error String - Result of XMPP error. Ex : [Error: XMPP authentication failure]\n *            data Object - Result of XMPP BOSH connection.\n *\n * Examples:\n *   var cl = new xmpp.Client({\n *       jid: \"me@example.com\",\n *       password: \"secret\"\n *   })\n *   var gtalk = new xmpp.Client({\n *       jid: 'me@gmail.com',\n *       oauth2_token: 'xxxx.xxxxxxxxxxx', // from OAuth2\n *       oauth2_auth: 'http://www.google.com/talk/protocol/auth',\n *       host: 'talk.google.com'\n *   })\n *   var prebind = new xmpp.Client({\n *       jid: \"me@example.com\",\n *       password: \"secret\",\n *       bosh: {\n *           url: \"http://example.com/http-bind\",\n *           prebind: function(error, data) {\n *               if (error) {}\n *               res.send({ rid: data.rid, sid: data.sid })\n *           }\n *       }\n *   })\n *\n * Example SASL EXTERNAL:\n *\n * var myCredentials = {\n *   // These are necessary only if using the client certificate authentication\n *   key: fs.readFileSync('key.pem'),\n *   cert: fs.readFileSync('cert.pem'),\n *   // passphrase: 'optional'\n * }\n * var cl = new xmppClient({\n *     jid: \"me@example.com\",\n *     credentials: myCredentials\n *     preferred: 'EXTERNAL' // not really required, but possible\n * })\n *\n */\nfunction Client (options) {\n  this.options = {}\n  if (options) this.options = options\n  this.availableSaslMechanisms = [\n    XOAuth2, External, DigestMD5, Plain, Anonymous\n  ]\n\n  if (this.options.autostart !== false) this.connect()\n}\n\ninherits(Client, Session)\n\nClient.NS_CLIENT = NS_CLIENT\n\nClient.prototype.connect = function () {\n  if (this.options.bosh && this.options.bosh.prebind) {\n    return this._connectViaBosh()\n  }\n  this._useStandardConnect()\n}\n\nClient.prototype._useStandardConnect = function () {\n  this.options.xmlns = NS_CLIENT\n  delete this.did_bind\n  delete this.did_session\n\n  this.state = STATE_PREAUTH\n  this.on('end', function () {\n    this.state = STATE_PREAUTH\n    delete this.did_bind\n    delete this.did_session\n  })\n\n  Session.call(this, this.options)\n  this.options.jid = this.jid\n\n  this.connection.on('disconnect', function (error) {\n    this.state = STATE_PREAUTH\n    if (!this.connection.reconnect) {\n      if (error) this.emit('error', error)\n      this.emit('offline')\n    }\n    delete this.did_bind\n    delete this.did_session\n  }.bind(this))\n\n  /* If server and client have multiple possible auth mechanisms\n   * we try to select the preferred one\n   */\n  if (this.options.preferred) {\n    this.preferredSaslMechanism = this.options.preferred\n  } else {\n    this.preferredSaslMechanism = 'DIGEST-MD5'\n  }\n\n  var mechs = sasl.detectMechanisms(this.options, this.availableSaslMechanisms)\n  this.availableSaslMechanisms = mechs\n}\n\nClient.prototype._connectViaBosh = function () {\n  debug('load bosh prebind')\n  var cb = this.options.bosh.prebind\n  delete this.options.bosh.prebind\n  var cmd = 'node ' + path.join(__dirname, 'prebind.js') + ' ' + encodeURI(JSON.stringify(this.options))\n  exec(\n    cmd,\n    function (error, stdout, stderr) {\n      if (error) {\n        cb(error, null)\n      } else {\n        var r = stdout.match(/rid:+[ 0-9]*/i)\n        var s = stdout.match(/sid:+[ a-z+'\"-_A-Z+0-9]*/i)\n        if (!r || !s) {\n          return cb(stderr)\n        }\n        r = (r[0].split(':'))[1].trim()\n\n        s = (s[0].split(':'))[1]\n          .replace(\"'\", '')\n          .replace(\"'\", '')\n          .trim()\n        if (r && s) {\n          return cb(null, { rid: r, sid: s })\n        }\n        cb(stderr)\n      }\n    }\n  )\n}\n\nClient.prototype.onStanza = function (stanza) {\n  /* Actually, we shouldn't wait for <stream:features/> if\n   * this.streamAttrs.version is missing, but who uses pre-XMPP-1.0\n   * these days anyway?\n   */\n  if (stanza.name === 'stream:error') {\n    return this._handleStreamError(stanza)\n  }\n  if ((this.state !== STATE_ONLINE) && stanza.is('features')) {\n    this.streamFeatures = stanza\n    return this.useFeatures()\n  }\n  this._handleStanza(stanza)\n}\n\nClient.prototype._handleStanza = function (stanza) {\n  switch (this.state) {\n    case STATE_ONLINE:\n      this.emit('stanza', stanza)\n      break\n    case STATE_PREAUTH:\n      this.emit('stanza:preauth', stanza)\n      break\n    case STATE_AUTH:\n      this._handleAuthState(stanza)\n      break\n    case STATE_BIND:\n      if (stanza.is('iq') && (stanza.attrs.id === IQID_BIND)) {\n        this._handleBindState(stanza)\n      }\n      break\n    case STATE_SESSION:\n      if ((stanza.is('iq') === true) && (stanza.attrs.id === IQID_SESSION)) {\n        this._handleSessionState(stanza)\n      }\n      break\n  }\n}\n\nClient.prototype._handleStreamError = function (stanza) {\n  if (!this.reconnect) {\n    this.emit('error', stanza)\n  }\n}\n\nClient.prototype._handleSessionState = function (stanza) {\n  if (stanza.attrs.type === 'result') {\n    this.state = STATE_AUTHED\n    this.did_session = true\n\n    /* no stream restart, but next feature (most probably\n       we'll go online next) */\n    this.useFeatures()\n  } else {\n    this.emit('error', 'Cannot bind resource')\n  }\n}\n\nClient.prototype._handleBindState = function (stanza) {\n  if (stanza.attrs.type === 'result') {\n    this.state = STATE_AUTHED\n    this.did_bind = true\n\n    var bindEl = stanza.getChild('bind', NS_XMPP_BIND)\n    if (bindEl && bindEl.getChild('jid')) {\n      this.jid = new JID(bindEl.getChild('jid').getText())\n    }\n\n    /* no stream restart, but next feature */\n    this.useFeatures()\n  } else {\n    this.emit('error', 'Cannot bind resource')\n  }\n}\n\nClient.prototype._handleAuthState = function (stanza) {\n  if (stanza.is('challenge', NS_XMPP_SASL)) {\n    var challengeMsg = decode64(stanza.getText())\n    var responseMsg = encode64(this.mech.challenge(challengeMsg))\n    var response = new Element('response', {xmlns: NS_XMPP_SASL}).t(responseMsg)\n    this.send(response)\n  } else if (stanza.is('success', NS_XMPP_SASL)) {\n    this.mech = null\n    this.state = STATE_AUTHED\n    this.emit('auth')\n  } else {\n    this.emit('error', 'XMPP authentication failure')\n  }\n}\n\nClient.prototype._handlePreAuthState = function () {\n  this.state = STATE_AUTH\n  var offeredMechs = this.streamFeatures.getChild('mechanisms', NS_XMPP_SASL).getChildren('mechanism', NS_XMPP_SASL).map(function (el) { return el.getText() })\n  this.mech = sasl.selectMechanism(\n    offeredMechs,\n    this.preferredSaslMechanism,\n    this.availableSaslMechanisms\n  )\n  if (this.mech) {\n    this.mech.authzid = this.jid.bare().toString()\n    this.mech.authcid = this.jid.local\n    this.mech.password = this.password\n    this.mech.api_key = this.api_key\n    this.mech.access_token = this.access_token\n    this.mech.oauth2_token = this.oauth2_token\n    this.mech.oauth2_auth = this.oauth2_auth\n    this.mech.realm = this.jid.domain // anything?\n    if (this.actAs) this.mech.actAs = this.actAs.user\n    this.mech.digest_uri = 'xmpp/' + this.jid.domain\n    var authMsg = encode64(this.mech.auth())\n    var attrs = this.mech.authAttrs()\n    attrs.xmlns = NS_XMPP_SASL\n    attrs.mechanism = this.mech.name\n    this.send(new Element('auth', attrs).t(authMsg))\n  } else {\n    this.emit('error', new Error('No usable SASL mechanism'))\n  }\n}\n\n/**\n * Either we just received <stream:features/>, or we just enabled a\n * feature and are looking for the next.\n */\nClient.prototype.useFeatures = function () {\n  if ((this.state === STATE_PREAUTH) && this.register) {\n    delete this.register\n    this.doRegister()\n  } else if ((this.state === STATE_PREAUTH) &&\n    this.streamFeatures.getChild('mechanisms', NS_XMPP_SASL)) {\n    this._handlePreAuthState()\n  } else if ((this.state === STATE_AUTHED) &&\n    !this.did_bind &&\n    this.streamFeatures.getChild('bind', NS_XMPP_BIND)) {\n    this.state = STATE_BIND\n    var bindEl = new Stanza('iq', {\n      type: 'set',\n      id: IQID_BIND\n    }).c('bind', { xmlns: NS_XMPP_BIND })\n    if (this.jid.resource) {\n      bindEl.c('resource').t(this.jid.resource)\n    }\n    this.send(bindEl)\n  } else if ((this.state === STATE_AUTHED) &&\n    !this.did_session &&\n    this.streamFeatures.getChild('session', NS_XMPP_SESSION)) {\n    this.state = STATE_SESSION\n    var stanza = new Stanza('iq', {\n      type: 'set',\n      to: this.jid.domain,\n      id: IQID_SESSION\n    }).c('session', { xmlns: NS_XMPP_SESSION })\n    this.send(stanza)\n  } else if (this.state === STATE_AUTHED) {\n    /* Ok, we're authenticated and all features have been\n       processed */\n    this.state = STATE_ONLINE\n    this.emit('online', { jid: this.jid })\n  }\n}\n\nClient.prototype.doRegister = function () {\n  var id = 'register' + Math.ceil(Math.random() * 99999)\n  var iq = new Stanza('iq', {\n    type: 'set',\n    id: id,\n    to: this.jid.domain\n  }).c('query', {xmlns: NS_REGISTER})\n    .c('username').t(this.jid.local).up()\n    .c('password').t(this.password)\n  this.send(iq)\n\n  var self = this\n  var onReply = function (reply) {\n    if (reply.is('iq') && (reply.attrs.id === id)) {\n      self.removeListener('stanza', onReply)\n\n      if (reply.attrs.type === 'result') {\n        /* Registration successful, proceed to auth */\n        self.useFeatures()\n      } else {\n        self.emit('error', new Error('Registration error'))\n      }\n    }\n  }\n  this.on('stanza:preauth', onReply)\n}\n\n/**\n * returns all registered sasl mechanisms\n */\nClient.prototype.getSaslMechanisms = function () {\n  return this.availableSaslMechanisms\n}\n\n/**\n * removes all registered sasl mechanisms\n */\nClient.prototype.clearSaslMechanism = function () {\n  this.availableSaslMechanisms = []\n}\n\n/**\n * register a new sasl mechanism\n */\nClient.prototype.registerSaslMechanism = function (method) {\n  // check if method is registered\n  if (this.availableSaslMechanisms.indexOf(method) === -1) {\n    this.availableSaslMechanisms.push(method)\n  }\n}\n\n/**\n * unregister an existing sasl mechanism\n */\nClient.prototype.unregisterSaslMechanism = function (method) {\n  // check if method is registered\n  var index = this.availableSaslMechanisms.indexOf(method)\n  if (index >= 0) {\n    this.availableSaslMechanisms = this.availableSaslMechanisms.splice(index, 1)\n  }\n}\n\nmodule.exports = Client\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-client/lib/session.js":"'use strict'\n\nvar tls = require('tls')\nvar EventEmitter = require('events').EventEmitter\nvar core = require('node-xmpp-core')\nvar inherits = core.inherits\nvar Connection = core.Connection\nvar JID = core.JID\nvar SRV = core.SRV\nvar BOSHConnection = require('./bosh')\nvar WSConnection = require('./websockets')\nvar debug = require('debug')('xmpp:client:session')\n\nfunction Session (opts) {\n  EventEmitter.call(this)\n\n  this.setOptions(opts)\n\n  if (opts.websocket && opts.websocket.url) {\n    debug('start websocket connection')\n    this._setupWebsocketConnection(opts)\n  } else if (opts.bosh && opts.bosh.url) {\n    debug('start bosh connection')\n    this._setupBoshConnection(opts)\n  } else {\n    debug('start socket connection')\n    this._setupSocketConnection(opts)\n  }\n}\n\ninherits(Session, EventEmitter)\n\nSession.prototype._setupSocketConnection = function (opts) {\n  var params = {\n    xmlns: { '': opts.xmlns },\n    streamAttrs: {\n      version: '1.0',\n      to: this.jid.domain\n    },\n    serialized: opts.serialized\n  }\n  for (var key in opts) {\n    if (!(key in params)) {\n      params[key] = opts[key]\n    }\n  }\n\n  this.connection = new Connection(params)\n  this._addConnectionListeners()\n\n  if (opts.host || opts.port) {\n    this._socketConnectionToHost(opts)\n  } else if (!SRV) {\n    throw new Error('Cannot load SRV')\n  } else {\n    this._performSrvLookup(opts)\n  }\n}\n\nSession.prototype._socketConnectionToHost = function (opts) {\n  var _this = this\n\n  if (opts.legacySSL) {\n    this.connection.allowTLS = false\n    this.connection.connect({\n      socket: function () {\n        return tls.connect(\n          opts.port || 5223,\n          opts.host || 'localhost',\n          opts.credentials || {},\n          function () {\n            if (this.socket.authorized) {\n              _this.emit('connect', this.socket)\n            } else {\n              _this.emit('error', 'unauthorized')\n            }\n          }.bind(this)\n        )\n      }\n    })\n  } else {\n    if (opts.credentials) {\n      this.connection.credentials = tls\n        .createSecureContext(opts.credentials)\n    }\n    if (opts.disallowTLS) this.connection.allowTLS = false\n    this.connection.listen({\n      socket: function () {\n        // wait for connect event listeners\n        process.nextTick(function () {\n          this.socket.connect(opts.port || 5222, opts.host)\n        }.bind(this))\n        var socket = opts.socket\n        opts.socket = null\n        return socket // maybe create new socket\n      }\n    })\n  }\n}\n\nSession.prototype._performSrvLookup = function (opts) {\n  if (opts.legacySSL) {\n    throw new Error('LegacySSL mode does not support DNS lookups')\n  }\n  if (opts.credentials) {\n    this.connection.credentials = tls.createSecureContext(opts.credentials)\n  }\n  if (opts.disallowTLS) {\n    this.connection.allowTLS = false\n  }\n  this.connection.listen({socket: SRV.connect({\n    socket: opts.socket,\n    services: ['_xmpp-client._tcp'],\n    domain: this.jid.domain,\n    defaultPort: 5222\n  })})\n}\n\nSession.prototype._setupBoshConnection = function (opts) {\n  this.connection = new BOSHConnection({\n    jid: this.jid,\n    bosh: opts.bosh\n  })\n  this._addConnectionListeners()\n  this.connection.on('connected', function () {\n    // Clients start <stream:stream>, servers reply\n    if (this.connection.startStream) {\n      this.connection.startStream()\n    }\n  }.bind(this))\n}\n\nSession.prototype._setupWebsocketConnection = function (opts) {\n  this.connection = new WSConnection({\n    jid: this.jid,\n    websocket: opts.websocket\n  })\n  this._addConnectionListeners()\n  this.connection.on('connected', function () {\n    // Clients start <stream:stream>, servers reply\n    if (this.connection.startStream) {\n      this.connection.startStream()\n    }\n  }.bind(this))\n}\n\nSession.prototype.setOptions = function (opts) {\n  this.jid = (typeof opts.jid === 'string') ? new JID(opts.jid) : opts.jid\n  this.password = opts.password\n  this.preferredSaslMechanism = opts.preferredSaslMechanism\n  this.api_key = opts.api_key\n  this.access_token = opts.access_token\n  this.oauth2_token = opts.oauth2_token\n  this.oauth2_auth = opts.oauth2_auth\n  this.register = opts.register\n  if (typeof opts.actAs === 'string') {\n    this.actAs = new JID(opts.actAs)\n  } else {\n    this.actAs = opts.actAs\n  }\n}\n\nSession.prototype._addConnectionListeners = function (con) {\n  con = con || this.connection\n  con.on('stanza', this.onStanza.bind(this))\n  con.on('drain', this.emit.bind(this, 'drain'))\n  con.on('end', this.emit.bind(this, 'end'))\n  con.on('close', this.emit.bind(this, 'close'))\n  con.on('error', this.emit.bind(this, 'error'))\n  con.on('connect', this.emit.bind(this, 'connect'))\n  con.on('reconnect', this.emit.bind(this, 'reconnect'))\n  con.on('disconnect', this.emit.bind(this, 'disconnect'))\n  if (con.startStream) {\n    con.on('connect', function () {\n      // Clients start <stream:stream>, servers reply\n      con.startStream()\n    })\n    this.on('auth', function () {\n      con.startStream()\n    })\n  }\n}\n\nSession.prototype.pause = function () {\n  if (this.connection && this.connection.pause) {\n    this.connection.pause()\n  }\n}\n\nSession.prototype.resume = function () {\n  if (this.connection && this.connection.resume) {\n    this.connection.resume()\n  }\n}\n\nSession.prototype.send = function (stanza) {\n  return this.connection ? this.connection.send(stanza) : false\n}\n\nSession.prototype.end = function () {\n  if (this.connection) {\n    this.connection.end()\n  }\n}\n\nSession.prototype.onStanza = function () {}\n\nmodule.exports = Session\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-client/lib/bosh.js":"'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar core = require('node-xmpp-core')\nvar inherits = core.inherits\nvar ltx = core.ltx\nvar request = require('request')\nvar debug = require('debug')('xmpp:client:bosh')\n\nfunction BOSHConnection (opts) {\n  var that = this\n  EventEmitter.call(this)\n\n  this.boshURL = opts.bosh.url\n  this.jid = opts.jid\n  this.wait = opts.bosh.wait || 60\n  this.xmlnsAttrs = {\n    xmlns: 'http://jabber.org/protocol/httpbind',\n    'xmlns:xmpp': 'urn:xmpp:xbosh',\n    'xmlns:stream': 'http://etherx.jabber.org/streams'\n  }\n  if (opts.xmlns) {\n    for (var prefix in opts.xmlns) {\n      if (prefix) {\n        this.xmlnsAttrs['xmlns:' + prefix] = opts.xmlns[prefix]\n      } else {\n        this.xmlnsAttrs.xmlns = opts.xmlns[prefix]\n      }\n    }\n  }\n  this.currentRequests = 0\n  this.queue = []\n  this.rid = Math.ceil(Math.random() * 9999999999)\n\n  this.request({\n    to: this.jid.domain,\n    ver: '1.6',\n    wait: this.wait,\n    hold: '1',\n    content: this.contentType,\n    'xmpp:version': '1.0'\n  }, [], function (err, bodyEl) {\n    if (err) {\n      that.emit('error', err)\n    } else if (bodyEl && bodyEl.attrs) {\n      that.sid = bodyEl.attrs.sid\n      that.maxRequests = parseInt(bodyEl.attrs.requests, 10) || 2\n      if (that.sid && (that.maxRequests > 0)) {\n        that.emit('connect')\n        that.processResponse(bodyEl)\n        process.nextTick(that.mayRequest.bind(that))\n      } else {\n        that.emit('error', 'Invalid parameters')\n      }\n    }\n  })\n}\n\ninherits(BOSHConnection, EventEmitter)\n\nBOSHConnection.prototype.contentType = 'text/xml; charset=utf-8'\n\nBOSHConnection.prototype.send = function (stanza) {\n  this.queue.push(stanza.root())\n  process.nextTick(this.mayRequest.bind(this))\n}\n\nBOSHConnection.prototype.startStream = function () {\n  var that = this\n\n  this.rid++\n  this.request({\n    to: this.jid.domain,\n    'xmpp:restart': 'true'\n  },\n    [],\n    function (err, bodyEl) {\n      if (err) {\n        that.emit('error', err)\n        that.emit('disconnect')\n        that.emit('end')\n        delete that.sid\n        that.emit('close')\n      } else {\n        that.streamOpened = true\n        if (bodyEl) that.processResponse(bodyEl)\n\n        process.nextTick(that.mayRequest.bind(that))\n      }\n    })\n}\n\nBOSHConnection.prototype.processResponse = function (bodyEl) {\n  debug('process bosh server response ' + bodyEl.toString())\n  if (bodyEl && bodyEl.children) {\n    for (var i = 0; i < bodyEl.children.length; i++) {\n      var child = bodyEl.children[i]\n      if (child.name && child.attrs && child.children) {\n        this.emit('stanza', child)\n      }\n    }\n  }\n  if (bodyEl && (bodyEl.attrs.type === 'terminate')) {\n    if (!this.shutdown || bodyEl.attrs.condition) {\n      this.emit('error', new Error(bodyEl.attrs.condition || 'Session terminated'))\n    }\n    this.emit('disconnect')\n    this.emit('end')\n    this.emit('close')\n  }\n}\n\nBOSHConnection.prototype.mayRequest = function () {\n  var canRequest =\n  /* Must have a session already */\n  this.sid &&\n    /* We can only receive when one request is in flight */\n    ((this.currentRequests === 0) ||\n    /* Is there something to send, and are we allowed? */\n    (((this.queue.length > 0) && (this.currentRequests < this.maxRequests)))\n  )\n\n  if (!canRequest) return\n\n  var stanzas = this.queue\n  this.queue = []\n  this.rid++\n  this.request({}, stanzas, function (err, bodyEl) {\n    if (err) {\n      this.emit('error', err)\n      this.emit('disconnect')\n      this.emit('end')\n      delete this.sid\n      this.emit('close')\n    } else {\n      if (bodyEl) this.processResponse(bodyEl)\n\n      process.nextTick(this.mayRequest.bind(this))\n    }\n  }.bind(this))\n}\n\nBOSHConnection.prototype.end = function (stanzas) {\n  stanzas = stanzas || []\n  if (typeof stanzas !== Array) stanzas = [stanzas]\n\n  stanzas = this.queue.concat(stanzas)\n  this.shutdown = true\n  this.queue = []\n  this.rid++\n  this.request({ type: 'terminate' }, stanzas, function (err, bodyEl) {\n    if (err) {\n    } else if (bodyEl) {\n      this.processResponse(bodyEl)\n    }\n\n    this.emit('disconnect')\n    this.emit('end')\n    delete this.sid\n    this.emit('close')\n  }.bind(this))\n}\n\nBOSHConnection.prototype.maxHTTPRetries = 5\n\nBOSHConnection.prototype.request = function (attrs, children, cb, retry) {\n  var that = this\n  retry = retry || 0\n\n  attrs.rid = this.rid.toString()\n  if (this.sid) attrs.sid = this.sid\n\n  for (var k in this.xmlnsAttrs) {\n    attrs[k] = this.xmlnsAttrs[k]\n  }\n  var boshEl = new ltx.Element('body', attrs)\n  for (var i = 0; i < children.length; i++) {\n    boshEl.cnode(children[i])\n  }\n\n  debug('send bosh request:' + boshEl.toString())\n\n  request({\n    uri: this.boshURL,\n    method: 'POST',\n    headers: { 'Content-Type': this.contentType },\n    body: boshEl.toString()\n  },\n    function (err, res, body) {\n      that.currentRequests--\n\n      if (err) {\n        if (retry < that.maxHTTPRetries) {\n          return that.request(attrs, children, cb, retry + 1)\n        } else {\n          return cb(err)\n        }\n      }\n      if ((res.statusCode < 200) || (res.statusCode >= 400)) {\n        return cb(new Error('HTTP status ' + res.statusCode))\n      }\n\n      var bodyEl\n      try {\n        bodyEl = ltx.parse(body)\n      } catch (e) {\n        return cb(e)\n      }\n\n      if (bodyEl &&\n        (bodyEl.attrs.type === 'terminate') &&\n        bodyEl.attrs.condition) {\n        cb(new Error(bodyEl.attrs.condition))\n      } else if (bodyEl) {\n        cb(null, bodyEl)\n      } else {\n        cb(new Error('no <body/>'))\n      }\n    }\n  )\n  this.currentRequests++\n}\n\nmodule.exports = BOSHConnection\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-client/lib/websockets.js":"'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar core = require('node-xmpp-core')\nvar Element = core.Element\nvar StreamParser = core.StreamParser\nvar Connection = core.Connection\nvar inherits = core.inherits\nvar ws = require('ws')\n // we ignore ws in the browser field of package.json\nvar WebSocket = ws.Server ? ws : window.WebSocket\nvar debug = require('debug')('xmpp:client:websocket')\n\nvar NS_FRAMING = 'urn:ietf:params:xml:ns:xmpp-framing'\n\nfunction WSConnection (opts) {\n  EventEmitter.call(this)\n\n  this.url = opts.websocket.url\n  this.jid = opts.jid\n  this.xmlns = {\n    '': NS_FRAMING\n  }\n  this.websocket = new WebSocket(this.url, ['xmpp'], opts.websocket.options)\n  this.websocket.onopen = this.onopen.bind(this)\n  this.websocket.onmessage = this.onmessage.bind(this)\n  this.websocket.onclose = this.onclose.bind(this)\n  this.websocket.onerror = this.onerror.bind(this)\n}\n\ninherits(WSConnection, EventEmitter)\n\nWSConnection.prototype.maxStanzaSize = 65535\nWSConnection.prototype.xmppVersion = '1.0'\n\nWSConnection.prototype.onopen = function () {\n  this.startParser()\n  this.emit('connected')\n}\n\nWSConnection.prototype.startParser = function () {\n  var self = this\n  this.parser = new StreamParser(this.maxStanzaSize)\n\n  this.parser.on('start', function (attrs) {\n    self.streamAttrs = attrs\n    /* We need those xmlns often, store them extra */\n    self.streamNsAttrs = {}\n    for (var k in attrs) {\n      if ((k === 'xmlns') ||\n        (k.substr(0, 6) === 'xmlns:')) {\n        self.streamNsAttrs[k] = attrs[k]\n      }\n    }\n\n    /* Notify in case we don't wait for <stream:features/>\n       (Component or non-1.0 streams)\n     */\n    self.emit('streamStart', attrs)\n  })\n  this.parser.on('stanza', function (stanza) {\n    // self.onStanza(self.addStreamNs(stanza))\n    self.onStanza(stanza)\n  })\n  this.parser.on('error', this.onerror.bind(this))\n  this.parser.on('end', function () {\n    self.stopParser()\n    self.end()\n  })\n}\n\nWSConnection.prototype.stopParser = function () {\n  /* No more events, please (may happen however) */\n  if (this.parser) {\n    /* Get GC'ed */\n    delete this.parser\n  }\n}\n\nWSConnection.prototype.onmessage = function (msg) {\n  debug('ws msg <--', msg.data)\n  if (msg && msg.data && this.parser) {\n    this.parser.write(msg.data)\n  }\n}\n\nWSConnection.prototype.onStanza = function (stanza) {\n  if (stanza.is('error', Connection.NS_STREAM)) {\n    /* TODO: extract error text */\n    this.emit('error', stanza)\n  } else {\n    this.emit('stanza', stanza)\n  }\n}\n\nWSConnection.prototype.startStream = function () {\n  var attrs = {}\n  for (var k in this.xmlns) {\n    if (this.xmlns.hasOwnProperty(k)) {\n      if (!k) {\n        attrs.xmlns = this.xmlns[k]\n      } else {\n        attrs['xmlns:' + k] = this.xmlns[k]\n      }\n    }\n  }\n  if (this.xmppVersion) attrs.version = this.xmppVersion\n  if (this.streamTo) attrs.to = this.streamTo\n  if (this.jid) attrs.to = this.jid.domain\n\n  this.send(new Element('open', attrs))\n\n  this.streamOpened = true\n}\n\nWSConnection.prototype.send = function (stanza) {\n  if (stanza.root) stanza = stanza.root()\n\n  if (!stanza.attrs.xmlns && (stanza.is('iq') || stanza.is('presence') || stanza.is('message'))) {\n    stanza.attrs.xmlns = 'jabber:client'\n  }\n\n  stanza = stanza.toString()\n  debug('ws send -->', stanza)\n  this.websocket.send(stanza)\n}\n\nWSConnection.prototype.onclose = function () {\n  this.emit('disconnect')\n  this.emit('close')\n}\n\nWSConnection.prototype.end = function () {\n  this.send(new Element('close', {xmlns: NS_FRAMING}))\n  this.emit('disconnect')\n  this.emit('end')\n  if (this.websocket) this.websocket.close()\n}\n\nWSConnection.prototype.onerror = function (e) {\n  this.emit('error', e)\n}\n\nmodule.exports = WSConnection\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-client/lib/sasl.js":"'use strict'\n\nvar Mechanism = require('./authentication/mechanism')\n\n/**\n * Available methods for client-side authentication (Client)\n * @param  Array offeredMechs  methods offered by server\n * @param  Array preferredMech preferred methods by client\n * @param  Array availableMech available methods on client\n */\nfunction selectMechanism (offeredMechs, preferredMech, availableMech) {\n  var mechClasses = []\n  var byName = {}\n  var Mech\n  if (Array.isArray(availableMech)) {\n    mechClasses = mechClasses.concat(availableMech)\n  }\n  mechClasses.forEach(function (mechClass) {\n    byName[mechClass.prototype.name] = mechClass\n  })\n  /* Any preferred? */\n  if (byName[preferredMech] &&\n    (offeredMechs.indexOf(preferredMech) >= 0)) {\n    Mech = byName[preferredMech]\n  }\n  /* By priority */\n  mechClasses.forEach(function (mechClass) {\n    if (!Mech &&\n      (offeredMechs.indexOf(mechClass.prototype.name) >= 0)) {\n      Mech = mechClass\n    }\n  })\n\n  return Mech ? new Mech() : null\n}\n\n/**\n * Will detect the available mechanisms based on the given options\n * @param  {[type]} options client configuration\n * @param  Array availableMech available methods on client\n * @return {[type]}         available options\n */\nfunction detectMechanisms (options, availableMech) {\n  var mechClasses = availableMech || []\n\n  var detect = []\n  mechClasses.forEach(function (mechClass) {\n    var match = mechClass.prototype.match\n    if (match(options)) detect.push(mechClass)\n  })\n  return detect\n}\n\nexports.selectMechanism = selectMechanism\nexports.detectMechanisms = detectMechanisms\nexports.AbstractMechanism = Mechanism\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-client/lib/authentication/mechanism.js":"'use strict'\n\n/**\n * Each implemented mechanism offers multiple methods\n * - name : name of the auth method\n * - auth :\n * - match: checks if the client has enough options to\n *          offer this mechanis to xmpp servers\n * - authServer: takes a stanza and extracts the information\n */\n\nvar inherits = require('node-xmpp-core').inherits\nvar EventEmitter = require('events').EventEmitter\n\n// Mechanisms\nfunction Mechanism () {}\n\ninherits(Mechanism, EventEmitter)\n\nMechanism.prototype.authAttrs = function () {\n  return {}\n}\n\nmodule.exports = Mechanism\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-client/lib/authentication/anonymous.js":"'use strict'\n\nvar Mechanism = require('./mechanism')\nvar inherits = require('node-xmpp-core').inherits\n\n/**\n * @see http://tools.ietf.org/html/rfc4505\n * @see http://xmpp.org/extensions/xep-0175.html\n */\nfunction Anonymous () {}\n\ninherits(Anonymous, Mechanism)\n\nAnonymous.prototype.name = 'ANONYMOUS'\n\nAnonymous.prototype.auth = function () {\n  return this.authzid\n}\n\nAnonymous.prototype.match = function () {\n  return true\n}\n\nmodule.exports = Anonymous\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-client/lib/authentication/plain.js":"'use strict'\n\nvar inherits = require('node-xmpp-core').inherits\nvar Mechanism = require('./mechanism')\n\nfunction Plain () {}\n\ninherits(Plain, Mechanism)\n\nPlain.prototype.name = 'PLAIN'\n\nPlain.prototype.auth = function () {\n  return this.authzid + '\\0' +\n  this.authcid + '\\0' +\n  this.password\n}\n\nPlain.prototype.match = function (options) {\n  if (options.password) return true\n  return false\n}\n\nmodule.exports = Plain\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-client/lib/authentication/digestmd5.js":"'use strict'\n\nvar inherits = require('node-xmpp-core').inherits\nvar Mechanism = require('./mechanism')\nvar crypto = require('crypto')\nvar MD5 = require('md5.js')\n\n/**\n * Hash a string\n */\nfunction md5 (s, encoding) {\n  // we ignore crypto in the browser field of package.json\n  var hash = crypto.createHash ? crypto.createHash('md5') : new MD5()\n  return hash.update(s, 'binary').digest(encoding || 'binary')\n}\nfunction md5Hex (s) {\n  return md5(s, 'hex')\n}\n\n/**\n * Parse SASL serialization\n */\nfunction parseDict (s) {\n  var result = {}\n  while (s) {\n    var m\n    if ((m = /^(.+?)=(.*?[^\\\\]),\\s*(.*)/.exec(s))) {\n      result[m[1]] = m[2].replace(/\"/g, '')\n      s = m[3]\n    } else if ((m = /^(.+?)=(.+?),\\s*(.*)/.exec(s))) {\n      result[m[1]] = m[2]\n      s = m[3]\n    } else if ((m = /^(.+?)=\"(.*?[^\\\\])\"$/.exec(s))) {\n      result[m[1]] = m[2]\n      s = m[3]\n    } else if ((m = /^(.+?)=(.+?)$/.exec(s))) {\n      result[m[1]] = m[2]\n      s = m[3]\n    } else {\n      s = null\n    }\n  }\n  return result\n}\n\n/**\n * SASL serialization\n */\nfunction encodeDict (dict) {\n  var s = ''\n  for (var k in dict) {\n    var v = dict[k]\n    if (v) s += ',' + k + '=\"' + v + '\"'\n  }\n  return s.substr(1) // without first ','\n}\n\n/**\n * Right-justify a string,\n * eg. pad with 0s\n */\nfunction rjust (s, targetLen, padding) {\n  while (s.length < targetLen) {\n    s = padding + s\n  }\n  return s\n}\n\n/**\n * Generate a string of 8 digits\n * (number used once)\n */\nfunction generateNonce () {\n  var result = ''\n  for (var i = 0; i < 8; i++) {\n    result += String.fromCharCode(48 +\n      Math.ceil(Math.random() * 10))\n  }\n  return result\n}\n\n/**\n * @see http://tools.ietf.org/html/rfc2831\n * @see http://wiki.xmpp.org/web/SASLandDIGEST-MD5\n */\nfunction DigestMD5 () {\n  this.nonce_count = 0\n  this.cnonce = generateNonce()\n  this.authcid = null\n  this.actAs = null\n  this.realm = null\n  this.password = null\n}\n\ninherits(DigestMD5, Mechanism)\n\nDigestMD5.prototype.name = 'DIGEST-MD5'\n\nDigestMD5.prototype.auth = function () {\n  return ''\n}\n\nDigestMD5.prototype.getNC = function () {\n  return rjust(this.nonce_count.toString(), 8, '0')\n}\n\nDigestMD5.prototype.responseValue = function (s) {\n  var dict = parseDict(s)\n  if (dict.realm) {\n    this.realm = dict.realm\n  }\n\n  var value\n  if (dict.nonce && dict.qop) {\n    this.nonce_count++\n    var a1 = md5(this.authcid + ':' +\n        this.realm + ':' +\n        this.password) + ':' +\n      dict.nonce + ':' +\n      this.cnonce\n    if (this.actAs) a1 += ':' + this.actAs\n\n    var a2 = 'AUTHENTICATE:' + this.digest_uri\n    if ((dict.qop === 'auth-int') || (dict.qop === 'auth-conf')) {\n      a2 += ':00000000000000000000000000000000'\n    }\n\n    value = md5Hex(md5Hex(a1) + ':' +\n      dict.nonce + ':' +\n      this.getNC() + ':' +\n      this.cnonce + ':' +\n      dict.qop + ':' +\n      md5Hex(a2))\n  }\n  return value\n}\n\nDigestMD5.prototype.challenge = function (s) {\n  var dict = parseDict(s)\n  if (dict.realm) {\n    this.realm = dict.realm\n  }\n\n  var response\n  if (dict.nonce && dict.qop) {\n    var responseValue = this.responseValue(s)\n    response = {\n      username: this.authcid,\n      realm: this.realm,\n      nonce: dict.nonce,\n      cnonce: this.cnonce,\n      nc: this.getNC(),\n      qop: dict.qop,\n      'digest-uri': this.digest_uri,\n      response: responseValue,\n      charset: 'utf-8'\n    }\n    if (this.actAs) response.authzid = this.actAs\n  } else if (dict.rspauth) {\n    return ''\n  }\n  return encodeDict(response)\n}\n\nDigestMD5.prototype.serverChallenge = function () {\n  var dict = {}\n  dict.realm = ''\n  this.nonce = dict.nonce = generateNonce()\n  dict.qop = 'auth'\n  this.charset = dict.charset = 'utf-8'\n  dict.algorithm = 'md5-sess'\n  return encodeDict(dict)\n}\n\n// Used on the server to check for auth!\nDigestMD5.prototype.response = function (s) {\n  var dict = parseDict(s)\n  this.authcid = dict.username\n\n  if (dict.nonce !== this.nonce) return false\n  if (!dict.cnonce) return false\n\n  this.cnonce = dict.cnonce\n  if (this.charset !== dict.charset) return false\n\n  this.response = dict.response\n  return true\n}\n\nDigestMD5.prototype.match = function (options) {\n  if (options.password) return true\n  return false\n}\n\nmodule.exports = DigestMD5\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-client/lib/authentication/xoauth2.js":"'use strict'\n\nvar inherits = require('node-xmpp-core').inherits\nvar Mechanism = require('./mechanism')\n\n/**\n * @see https://developers.google.com/talk/jep_extensions/oauth\n */\nfunction XOAuth2 () {\n  this.oauth2_auth = null\n  this.authzid = null\n}\n\ninherits(XOAuth2, Mechanism)\n\nXOAuth2.prototype.name = 'X-OAUTH2'\nXOAuth2.prototype.NS_GOOGLE_AUTH = 'http://www.google.com/talk/protocol/auth'\n\nXOAuth2.prototype.auth = function () {\n  return '\\0' + this.authzid + '\\0' + this.oauth2_token\n}\n\nXOAuth2.prototype.authAttrs = function () {\n  return {\n    'auth:service': 'oauth2',\n    'xmlns:auth': this.oauth2_auth\n  }\n}\n\nXOAuth2.prototype.match = function (options) {\n  return (options.oauth2_auth === XOAuth2.prototype.NS_GOOGLE_AUTH)\n}\n\nmodule.exports = XOAuth2\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-client/lib/authentication/external.js":"'use strict'\n\nvar inherits = require('node-xmpp-core').inherits\nvar Mechanism = require('./mechanism')\n\n/**\n * @see http://xmpp.org/extensions/xep-0178.html\n */\nfunction External () {}\n\ninherits(External, Mechanism)\n\nExternal.prototype.name = 'EXTERNAL'\n\nExternal.prototype.auth = function () {\n  return (this.authzid)\n}\n\nExternal.prototype.match = function (options) {\n  if (options.credentials) return true\n  return false\n}\n\nmodule.exports = External\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/index.js":"'use strict'\n\nvar BOSHServer = require('./lib/C2S/BOSH/Server')\nvar TCPServer = require('./lib/C2S/TCP/Server')\nvar C2SServer = require('./lib/C2S/Server')\nvar C2SSession = require('./lib/C2S/Session')\nvar WebSocketServer = require('./lib/C2S/WebSocket/Server')\nvar ComponentServer = require('./lib/component/Server')\nvar ComponentSession = require('./lib/component/Session')\nvar core = require('node-xmpp-core')\n\nmodule.exports = {\n  _Server: require('./lib/Server'),\n\n  // S2S\n  Router: require('./lib/S2S/Router'),\n\n  // C2S\n  C2S: {\n    _Server: C2SServer,\n    _Session: C2SSession,\n\n    // TCP\n    TCPServer: TCPServer,\n\n    // BOSH\n    BOSHServer: BOSHServer,\n    _BOSHSocket: require('./lib/C2S/BOSH/Socket'),\n    _BOSHServer: require('./lib/C2S/BOSH/BOSHServer'),\n\n    // WebSocket\n    WebSocketServer: WebSocketServer,\n    _WebSocketSocket: require('./lib/C2S/WebSocket/Socket')\n  },\n  C2SServer: TCPServer,\n  C2SStream: C2SSession,\n  BOSHServer: BOSHServer,\n  WebSocketServer: WebSocketServer,\n\n  // Component\n  component: {\n    Server: ComponentServer,\n    Session: ComponentSession\n  },\n  ComponentServer: ComponentServer,\n  ComponentStream: ComponentSession,\n\n  // SASL\n  auth: {\n    AbstractMechanism: require('./lib/C2S/authentication/Mechanism'),\n    Mechanism: require('./lib/C2S/authentication/Mechanism'),\n    Plain: require('./lib/C2S/authentication/Plain'),\n    DigestMD5: require('./lib/C2S/authentication/DigestMD5'),\n    XOAuth2: require('./lib/C2S/authentication/XOAuth2'),\n    Anonymous: require('./lib/C2S/authentication/Anonymous')\n  }\n}\n\ncore.exportCoreUtils(module.exports)\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/C2S/BOSH/Server.js":"'use strict'\n\nvar util = require('util')\nvar Server = require('./BOSHServer')\nvar C2SServer = require('../Server')\n\nvar BOSH_PORT = 5280\n\n/**\n * [BOSHServer description]\n *\n *   options.port : BOSH_PORT\n *   options.autostart : autostarts the server\n *\n * Some default ports are:\n * - http://example.com:5280/http-bind\n * - https://example.com:5281/http-bind\n */\nfunction BOSHServer (opts) {\n  var options = opts || {}\n  var server = this.server = new Server({\n    server: options.server,\n    cors: options.cors,\n    nextRequestTimeout: options.nextRequestTimeout\n  })\n  server.on('close', this.emit.bind(this, 'close'))\n  server.on('error', this.emit.bind(this, 'error'))\n  server.on('listening', this.emit.bind(this, 'listening'))\n  server.on('connection', this.acceptConnection.bind(this))\n\n  C2SServer.call(this, options)\n}\n\nutil.inherits(BOSHServer, C2SServer)\n\nBOSHServer.prototype.DEFAULT_PORT = BOSH_PORT\n\nmodule.exports = BOSHServer\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/C2S/BOSH/BOSHServer.js":"'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar ltx = require('node-xmpp-core').ltx\nvar Socket = require('./Socket')\nvar debug = require('debug')('xmpp:bosh:http')\nvar http = require('http')\nvar serverStop = require('../../serverStop')\n\nvar NS_HTTPBIND = 'http://jabber.org/protocol/httpbind'\nvar NEXT_REQUEST_TIMEOUT = 60 * 1000\n\nfunction parseBody (stream, cb) {\n  var parser = new ltx.Parser()\n  stream.on('data', function (data) {\n    parser.write(data)\n  })\n  stream.on('end', function () {\n    parser.end()\n  })\n  stream.on('error', function (e) {\n    cb(e)\n  })\n  parser.on('tree', function (bodyEl) {\n    cb(null, bodyEl)\n  })\n  parser.on('error', function (e) {\n    cb(e)\n  })\n}\n\nfunction BOSHServer (options) {\n  EventEmitter.call(this)\n  this.options = options || {}\n  this.nextRequestTimeout = this.options.nextRequestTimeout || NEXT_REQUEST_TIMEOUT\n\n  // set default cors properties\n  if (!this.options.cors) {\n    this.options.cors = {}\n  }\n  for (var i in this.corsHeaders) {\n    if (typeof this.options.cors[i] === 'undefined') {\n      this.options.cors[i] = this.corsHeaders[i]\n    }\n  }\n\n  this.sessions = Object.create(null)\n\n  var server = this.server = serverStop(this.options.server || http.createServer())\n  server.on('request', this.onRequest.bind(this))\n  server.on('close', this.emit.bind(this, 'close'))\n  server.on('error', this.emit.bind(this, 'error'))\n  server.on('listening', this.emit.bind(this, 'listening'))\n}\n\nutil.inherits(BOSHServer, EventEmitter)\n\nBOSHServer.prototype.corsHeaders = {\n  origin: '*',\n  methods: [\n    'POST',\n    'OPTIONS'\n  ],\n  headers: [\n    'X-Requested-With',\n    'Content-Type',\n    'Content-Length'\n  ],\n  credentials: false\n}\n\nBOSHServer.prototype.setCorsHeader = function (req, res, options) {\n  var origin = options.origin\n  if (Array.isArray(options.origin)) {\n    origin = options.origin.indexOf(req.headers.origin) > -1 ? req.headers.origin : undefined\n  } else if (options.origin === '*') {\n    origin = req.headers.origin\n  }\n\n  if (origin) {\n    res.setHeader('Access-Control-Allow-Origin', origin)\n  }\n  res.setHeader('Access-Control-Allow-Credentials', options.credentials)\n  res.setHeader('Access-Control-Allow-Methods', options.methods.join(', '))\n  res.setHeader('Access-Control-Allow-Headers', options.headers.join(', '))\n}\n\nBOSHServer.prototype.listen = function () {\n  this.server.listen.apply(this.server, arguments)\n}\n\nBOSHServer.prototype.close = function () {\n  this.server.close.apply(this.server, arguments)\n}\n\nBOSHServer.prototype.stop = function () {\n  this.server.stop.apply(this.server, arguments)\n}\n\n/**\n * *YOU* need to check the path before passing to this function.\n */\nBOSHServer.prototype.onRequest = function (req, res) {\n  debug('handle http')\n  this.setCorsHeader(req, res, this.options.cors)\n  if (req.method === 'OPTIONS') {\n    res.writeHead(200)\n    res.end()\n  } else if (req.method === 'POST') {\n    this._handlePostRequest(req, res)\n  } else {\n    res.writeHead(405, {\n      'Allow': 'OPTIONS, POST'\n    })\n    res.end()\n  }\n}\n\nBOSHServer.prototype._handlePostRequest = function (req, res) {\n  debug('handle POST request')\n  var self = this\n  parseBody(req, function (error, bodyEl) {\n    if (error ||\n      !bodyEl || !bodyEl.attrs || !bodyEl.is ||\n      !bodyEl.is('body', NS_HTTPBIND)\n    ) {\n      return self._sendErrorResponse(res, error)\n    }\n\n    debug('got: ' + bodyEl.toString())\n\n    if (bodyEl.attrs.sid) {\n      debug('sid found, reuse existing session')\n      self._useExistingSession(req, res, bodyEl)\n    } else {\n      debug('no sid found, create a new session')\n      self._createSession(req, res, bodyEl)\n    }\n  })\n}\n\nBOSHServer.prototype._sendErrorResponse = function (res, error) {\n  res.writeHead(400, { 'Content-Type': 'text/plain' })\n\n  var body\n  if (error instanceof Error) {\n    body = error.message || error.stack\n  } else if (typeof error === 'string') {\n    body = error\n  } else {\n    body = 'error'\n  }\n\n  res.end(body)\n}\n\nBOSHServer.prototype._useExistingSession = function (req, res, bodyEl) {\n  var session = this.sessions[bodyEl.attrs.sid]\n  if (session) {\n    debug('session for sid', bodyEl.attrs.sid, 'found', process.pid)\n    session.handleHTTP(\n      { req: req, res: res, bodyEl: bodyEl }\n    )\n    res.once('close', function () {\n      session.closeSocket()\n    })\n  } else {\n    debug('no session found for sid', bodyEl.attrs.sid, process.pid)\n    res.writeHead(\n      404, { 'Content-Type': 'text/plain' }\n    )\n    res.end('BOSH session not found')\n  }\n}\n\nBOSHServer.prototype._createSession = function (req, res, bodyEl) {\n  debug('create a new session')\n\n  var self = this\n  var session = new Socket({\n    req: req,\n    res: res,\n    bodyEl: bodyEl,\n    nextRequestTimeout: this.nextRequestTimeout\n  })\n  this.sessions[session.sid] = session\n\n  // Hook for destruction\n  session.once('close', function () {\n    delete self.sessions[session.sid]\n  })\n\n  res.boshAttrs = {'xmpp:restartlogic': true}\n\n  // emit new connection\n  this.emit('connection', session)\n}\n\nmodule.exports = BOSHServer\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/C2S/BOSH/Socket.js":"'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar ltx = require('node-xmpp-core').ltx\nvar hat = require('hat')\nvar debug = require('debug')('xmpp:bosh:session')\n\nvar NS_HTTPBIND = 'http://jabber.org/protocol/httpbind'\n\n/**\n * Gets constructed with a first HTTP request (opts.req & opts.res),\n * but receives more in method handleHTTP().\n *\n * The BOSH server session behaves like a normal socket and emits all proper\n * messages to a connection\n *\n * Implement the follwing methods\n * serializeStanza()\n * write()\n * pause()\n * resume()\n * end()\n *\n * Implement the following events:\n * this.emit('connect')\n * this.emit('data', string)\n * this.emit('end')\n * this.emit('close')\n *\n * License: MIT\n */\nfunction BOSHSession (opts) {\n  // socket properties\n  this.writable = true\n  this.readable = true\n\n  // BOSH settings\n  this.nextRequestTimeout = opts.nextRequestTimeout\n  if (opts.xmlns) {\n    for (var prefix in opts.xmlns) {\n      if (prefix) {\n        this.xmlnsAttrs['xmlns:' + prefix] = opts.xmlns[prefix]\n      } else {\n        this.xmlnsAttrs.xmlns = opts.xmlns[prefix]\n      }\n    }\n  }\n  this.streamAttrs = opts.streamAttrs || {}\n  this.handshakeAttrs = opts.bodyEl.attrs\n\n  // generate sid\n  this.sid = opts.sid || hat()\n  // add sid to properties\n  this.xmlnsAttrs.sid = this.sid\n\n  this.nextRid = parseInt(opts.bodyEl.attrs.rid, 10)\n  this.wait = parseInt(opts.bodyEl.attrs.wait || '30', 10)\n  this.hold = parseInt(opts.bodyEl.attrs.hold || '1', 10)\n  this.inQueue = Object.create(null)\n  this.outQueue = []\n  this.stanzaQueue = []\n\n  this.emit('connect')\n\n  this.inQueue[opts.bodyEl.attrs.rid] = opts\n  process.nextTick(this.workInQueue.bind(this))\n  this.setNextRequestTimeout()\n}\n\nutil.inherits(BOSHSession, EventEmitter)\n\nBOSHSession.prototype.name = 'BOSH'\n\nBOSHSession.prototype.xmlnsAttrs = {\n  xmlns: NS_HTTPBIND,\n  'xmlns:xmpp': 'urn:xmpp:xbosh',\n  'xmlns:stream': 'http://etherx.jabber.org/streams'\n}\n\n/**\n * implementation of socket interface\n * forwards data from connection to http\n */\nBOSHSession.prototype.write = function (data) {\n  this.stanzaQueue.push(data)\n\n  process.nextTick(this.workOutQueue.bind(this))\n  // indicates if we flush\n  return this.outQueue.length > 0\n}\n\nBOSHSession.prototype.serializeStanza = function (stanza, fn) {\n  fn(stanza.toString()) // No specific serialization\n}\n\nBOSHSession.prototype.pause = function () {}\n\nBOSHSession.prototype.resume = function () {}\n\nBOSHSession.prototype.end = function () {\n  debug('close connection')\n  this.closeSocket()\n}\n\n/**\n * internal method to emit data to Connection\n */\nBOSHSession.prototype.sendData = function (data) {\n  // emit this data to connection\n  debug('emit data: ' + data.toString())\n  this.emit('data', data.toString())\n}\n\nBOSHSession.prototype.closeSocket = function () {\n  debug('close socket')\n  this.resetNextRequestTimeout()\n  this.emit('end')\n  this.emit('close')\n}\n\n/**\n * handle http requests\n */\nBOSHSession.prototype.handleHTTP = function (opts) {\n  debug('handle http')\n  var oldOpts = this.inQueue[opts.bodyEl.attrs.rid]\n  if (oldOpts) {\n    // Already queued? Replace with this request\n    oldOpts.res.writeHead(\n      403,\n      { 'Content-Type': 'text/plain' }\n    )\n    oldOpts.res.end('Request replaced by same RID')\n  } else if (parseInt(opts.bodyEl.attrs.rid, 10) < parseInt(this.nextRid, 10)) {\n    // This req has already been processed.\n    this.outQueue.push(opts)\n    return\n  }\n\n  this.resetNextRequestTimeout()\n\n  // Set up timeout:\n  var self = this\n  opts.timer = setTimeout(function () {\n    delete opts.timer\n    self.onReqTimeout(opts.bodyEl.attrs.rid)\n  }, this.wait * 1000)\n\n  // Process...\n  this.inQueue[opts.bodyEl.attrs.rid] = opts\n  process.nextTick(this.workInQueue.bind(this))\n}\n\nBOSHSession.prototype.streamOpen = function (opts) {\n  /* eslint-disable indent */\n  return [\n    '<stream:stream ',\n    'xmlns=\"jabber:client\" ',\n    'xmlns:stream=\"http://etherx.jabber.org/streams\" ',\n    'to=\"' + opts.to + '\"',\n    opts.xmppv ? (' xmpp:version=\"' + opts.xmppv + '\"') : '',\n    '>'\n  ].join('')\n/* eslint-enable indent */\n}\n\nBOSHSession.prototype.workInQueue = function () {\n  debug('run workInQueue')\n\n  var opts = this.inQueue[this.nextRid]\n  if (!opts) {\n    // Still waiting for next rid request\n    return\n  }\n\n  var self = this\n  delete this.inQueue[this.nextRid]\n  this.nextRid++\n\n  // handle message\n\n  // extract values\n  var rid = opts.bodyEl.attrs.rid\n  var sid = opts.bodyEl.attrs.sid\n  var to = opts.bodyEl.attrs.to\n  var restart = opts.bodyEl.attrs['xmpp:restart']\n  var xmppv = opts.bodyEl.attrs['xmpp:version']\n\n  // handle stream start\n  if (!restart && rid && !sid) {\n    debug('handle stream start')\n    // emulate stream creation for connection\n    this.sendData(\n      '<?xml version=\"1.0\" ?>' +\n      this.streamOpen({to: to, xmppv: xmppv})\n    )\n  // handle stream reset\n  } else if (opts.bodyEl.attrs['xmpp:restart'] === 'true') {\n    debug('reset stream')\n    // emulate stream restart for connection\n    this.sendData(\n      this.streamOpen({to: to, xmppv: xmppv})\n    )\n  }\n\n  opts.bodyEl.children.forEach(function (stanza) {\n    debug('send data: ' + stanza)\n    // extract content\n    self.sendData(stanza.toString())\n  })\n\n  // Input process, retain response for sending stanzas\n  this.outQueue.push(opts)\n\n  if (opts.bodyEl.attrs.type !== 'terminate') {\n    debug('schedule response')\n    process.nextTick(function () {\n      self.workOutQueue()\n      self.workInQueue()\n    })\n  } else {\n    debug('terminate connection')\n    for (var i = 0; i < this.outQueue.length; i++) {\n      opts = this.outQueue[i]\n      if (opts.timer) clearTimeout(opts.timer)\n      this.respond(opts.res, { type: 'terminate' }, [])\n    }\n    this.outQueue = []\n    this.closeSocket()\n  }\n}\n\nBOSHSession.prototype.workOutQueue = function () {\n  debug('run workOutQueue')\n  if ((this.stanzaQueue.length < 1) &&\n    (this.outQueue.length > 0)) {\n    this.emit('drain')\n    return\n  } else if (this.outQueue.length < 1) {\n    return\n  }\n\n  // queued stanzas\n  var stanzas = this.stanzaQueue\n  this.stanzaQueue = []\n\n  // available requests\n  var opts = this.outQueue.shift()\n\n  if (opts.timer) {\n    clearTimeout(opts.timer)\n    delete opts.timer\n  }\n\n  // WORKAROUND https://github.com/node-xmpp/node-xmpp-server/issues/100\n  if (opts.res.connection.destroyed) {\n    return\n  }\n\n  // answer\n  this.respond(opts.res, {}, stanzas)\n\n  this.setNextRequestTimeout()\n}\n\nBOSHSession.prototype.setNextRequestTimeout = function () {\n  this.resetNextRequestTimeout()\n\n  if (this.outQueue.length > 0) {\n    return\n  }\n\n  var self = this\n  this.NRTimeout = setTimeout(function () {\n    self.emit('error', new Error('Session timeout'))\n    self.emit('close')\n  }, this.nextRequestTimeout)\n}\n\nBOSHSession.prototype.resetNextRequestTimeout = function () {\n  if (!this.NRTimeout) {\n    return\n  }\n\n  clearTimeout(this.NRTimeout)\n  delete this.NRTimeout\n}\n\nBOSHSession.prototype.onReqTimeout = function (rid) {\n  var opts = this.inQueue[rid]\n\n  if (opts) {\n    delete this.inQueue[rid]\n  } else {\n    for (var i = 0; i < this.outQueue.length; i++) {\n      if (this.outQueue[i].bodyEl.attrs.rid === rid) break\n    }\n\n    if (i < this.outQueue.length) {\n      opts = this.outQueue[i]\n      this.outQueue.splice(i, 1)\n    } else {\n      console.warn('Spurious timeout for BOSH rid', rid)\n      return\n    }\n  }\n  this.respond(opts.res, {})\n}\n\nBOSHSession.prototype.respond = function (res, attrs, children) {\n  res.writeHead(\n    200,\n    { 'Content-Type': 'text/xml; charset=utf-8' }\n  )\n  for (var k in this.xmlnsAttrs) {\n    attrs[k] = this.xmlnsAttrs[k]\n  }\n  if (res.boshAttrs) {\n    for (var i in res.boshAttrs) {\n      attrs[i] = res.boshAttrs[i]\n    }\n  }\n  var bodyEl = new ltx.Element('body', attrs)\n  if (children) {\n    // TODO, we need to filter the stream element\n    children.forEach(function (element) {\n      try {\n        bodyEl.cnode(ltx.parse(element))\n      } catch (err) {\n        console.error('could not parse' + element)\n      }\n    })\n  }\n  bodyEl.write(function (s) {\n    res.write(s)\n  })\n  res.end()\n}\n\nmodule.exports = BOSHSession\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/serverStop.js":"'use strict'\n\nmodule.exports = function (server) {\n  var connections = server.__connections = new Set()\n  server.on('connection', function (connection) {\n    if (server.__closing === true) {\n      connection.destroy()\n    }\n\n    connections.add(connection)\n    connection.once('close', function () {\n      connections.delete(connection)\n    })\n  })\n  server.stop = function () {\n    server.__closing = true\n    server.once('close', function () {\n      server.__closing = false\n    })\n    connections.forEach(function (connection) {\n      connection.destroy()\n    })\n  }\n  return server\n}\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/C2S/Server.js":"'use strict'\n\nvar Server = require('../Server')\nvar util = require('util')\nvar Plain = require('./authentication/Plain')\nvar Session = require('./Session')\n\n/**\n * params:\n *   options : port on which to listen to C2S connections\n *   options.port : xmpp tcp socket port\n *   options.domain : domain of xmpp server\n *   options.autostart : if we start listening at given port\n *   options.requestCert : expect a client certificate (see tls.createSecurePair for more)\n *   options.rejectUnauthorized : reject when client cert missmatches (see tls.createSecurePair for more)\n *   options.tls : wrapper object for tlc config\n *   options.tls.key : private key string\n *   options.tls.cert : certificate string\n *   options.tls.keyPath : path to key\n *   options.tls.certPath : path to certificate\n */\nfunction C2SServer (options) {\n  Server.call(this, options)\n\n  this.availableSaslMechanisms = [Plain]\n\n  // don't allow anybody by default when using client cert auth\n  if ((this.options.requestCert) &&\n    (this.options.rejectUnauthorized !== false)) {\n    this.options.rejectUnauthorized = true\n  }\n}\n\nutil.inherits(C2SServer, Server)\n\nC2SServer.prototype.Session = Session\n\n/**\n * returns all registered sasl mechanisms\n */\nC2SServer.prototype.getSaslMechanisms = function () {\n  return this.availableSaslMechanisms\n}\n\n/**\n * removes all registered sasl mechanisms\n */\nC2SServer.prototype.clearSaslMechanism = function () {\n  this.availableSaslMechanisms = []\n}\n\n/**\n * register a new sasl mechanism\n */\nC2SServer.prototype.registerSaslMechanism = function (method) {\n  // check if method is registered\n  if (this.availableSaslMechanisms.indexOf(method) === -1) {\n    this.availableSaslMechanisms.push(method)\n  }\n}\n\n/**\n * unregister an existing sasl mechanism\n */\nC2SServer.prototype.unregisterSaslMechanism = function (method) {\n  // check if method is registered\n  var index = this.availableSaslMechanisms.indexOf(method)\n  if (index >= 0) {\n    this.availableSaslMechanisms.splice(index, 1)\n  }\n}\n\nmodule.exports = C2SServer\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/Server.js":"'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\n\nfunction Server (options) {\n  EventEmitter.call(this)\n\n  this.options = options || {}\n  this.port = this.options.port || this.DEFAULT_PORT\n\n  this.connections = new Set()\n\n  this.on('connection', this.onConnection.bind(this))\n\n  // node-xmpp events\n  this.on('listening', this.emit.bind(this, 'online'))\n  this.on('close', this.emit.bind(this, 'offline'))\n  this.on('close', this.emit.bind(this, 'shutdown'))\n\n  /* And now start listening to connections on the\n   * port provided as an option.\n   */\n  if (this.server && this.options.autostart !== false) {\n    this.listen()\n  }\n}\n\nutil.inherits(Server, EventEmitter)\n\nServer.prototype.onConnection = function (connection) {\n  this.connections.add(connection)\n  connection.once('close', this.onConnectionClosed.bind(this, connection))\n  // backward compatibility FIXME remove me\n  this.emit('connect', connection)\n}\n\nServer.prototype.onConnectionClosed = function (connection) {\n  this.connections.delete(connection)\n// FIXME should we remove all listeners?\n}\n\nServer.prototype.acceptConnection = function (socket) {\n  var session = new this.Session({\n    rejectUnauthorized: this.options.rejectUnauthorized,\n    requestCert: this.options.requestCert,\n    socket: socket,\n    server: this,\n    streamOpen: this.options.streamOpen,\n    streamClose: this.options.streamClose,\n    streamAttrs: this.options.streamAttrs\n  })\n  socket.session = session\n  this.emit('connection', session)\n}\n\n/*\n * Those are meant to be overriden\n */\nServer.prototype.DEFAULT_PORT = null\nServer.prototype.Session = null\n\nServer.prototype.listen = function (port, host, fn) {\n  if (typeof port === 'function') {\n    fn = port\n    port = host = null\n  } else if (typeof host === 'function') {\n    fn = host\n    host = null\n  }\n\n  port = port || this.port\n  host = host || this.options.host || '::'\n\n  this.server.listen(port, host, fn)\n}\n\nServer.prototype.close = function () {\n  this.server.close.apply(this.server, arguments)\n}\n\nServer.prototype.end = function (fn) {\n  fn = fn || function () {}\n  this.once('close', fn)\n  this.close()\n  this.endSessions()\n  if (this.server && this.server.stop) this.server.stop()\n}\n\nServer.prototype.shutdown = Server.prototype.end\n\n// FIXME this should be async, data might not be drained\nServer.prototype.endSessions = function () {\n  var self = this\n  this.connections.forEach(function (session) {\n    session.removeListener('close', self.onConnectionClosed)\n    session.end()\n    self.connections.delete(session)\n  })\n}\n\nmodule.exports = Server\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/C2S/authentication/Plain.js":"'use strict'\n\nvar util = require('util')\nvar Mechanism = require('./Mechanism')\n\nfunction Plain () {}\n\nutil.inherits(Plain, Mechanism)\n\nPlain.prototype.name = 'PLAIN'\nPlain.id = 'PLAIN'\n\nPlain.prototype.extractSasl = function (auth) {\n  var params = auth.split('\\x00')\n  var authRequest = {\n    'username': params[1],\n    'password': params[2]\n  }\n  return authRequest\n}\n\nmodule.exports = Plain\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/C2S/authentication/Mechanism.js":"'use strict'\n\n/**\n * Each implemented mechanism offers multiple methods\n * - name : name of the auth method\n * - auth :\n * - match: checks if the client has enough options to\n *          offer this mechanis to xmpp servers\n * - authServer: takes a stanza and extracts the information\n */\n\nvar util = require('util')\nvar EventEmitter = require('events').EventEmitter\n\n// Mechanisms\nfunction Mechanism () {}\n\nutil.inherits(Mechanism, EventEmitter)\n\n// The following functions will be overridden by xmpp server\nMechanism.prototype = {\n  /**\n   * handle failures within the mechanism\n   * @param {String} error\n   */\n  success: function () {},\n\n  /**\n   * handle failures within the mechanism\n   * @param {String} error\n   */\n  failure: function () {},\n\n  authenticate: function () {},\n\n  manageAuth: function (stanza) {\n    var self = this\n\n    var auth = new Buffer(stanza.getText(), 'base64').toString('utf8')\n    this.authenticate(this.extractSasl(auth), function (err, user) {\n      if (!err && user) {\n        self.success(user)\n      } else {\n        self.failure(err)\n      }\n    })\n  }\n}\n\n// This method should be overrriden in custom mechanisms\nMechanism.prototype.extractSasl = function () {\n  throw new Error('This is an abstract method, you should overrride it')\n}\n\nmodule.exports = Mechanism\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/C2S/Session.js":"'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar core = require('node-xmpp-core')\nvar Element = core.Element\nvar JID = core.JID\nvar IQ = core.IQ\nvar Connection = core.Connection\nvar rack = require('hat').rack\n\nvar NS_CLIENT = 'jabber:client'\nvar NS_XMPP_SASL = 'urn:ietf:params:xml:ns:xmpp-sasl'\nvar NS_REGISTER = 'jabber:iq:register'\nvar NS_SESSION = 'urn:ietf:params:xml:ns:xmpp-session'\nvar NS_BIND = 'urn:ietf:params:xml:ns:xmpp-bind'\nvar NS_STANZAS = 'urn:ietf:params:xml:ns:xmpp-stanzas'\nvar NS_STREAMS = 'http://etherx.jabber.org/streams'\n\nfunction Session (opts) {\n  this.authenticated = false\n  this.server = opts.server\n  this.generateId = rack(opts.idBits, opts.idBitsBase, opts.idBitsExpandBy)\n\n  this.connection = opts.connection || new Connection({\n    rejectUnauthorized: opts.rejectUnauthorized,\n    requestCert: opts.requestCert,\n    reconnect: false,\n    streamOpen: opts.streamOpen,\n    streamClose: opts.streamClose,\n    streamAttrs: opts.streamAttrs\n  })\n  this._addConnectionListeners()\n  if (this.connection.xmlns) {\n    this.connection.xmlns[''] = NS_CLIENT\n  }\n  this.connection.streamAttrs.version = '1.0'\n  this.connection.streamAttrs.id = this.generateId()\n\n  if (this.connection.connect) {\n    this.connection.connect({socket: opts.socket})\n  }\n}\n\nutil.inherits(Session, EventEmitter)\n\nSession.prototype._addConnectionListeners = function (con) {\n  con = con || this.connection\n  con.on('stanza', this.onStanza.bind(this))\n  con.on('drain', this.emit.bind(this, 'drain'))\n  con.on('data', this.emit.bind(this, 'data'))\n  con.on('end', this.emit.bind(this, 'end'))\n  con.on('close', this.emit.bind(this, 'close'))\n  con.on('error', this.emit.bind(this, 'error'))\n  con.on('connect', this.emit.bind(this, 'connect'))\n  con.on('reconnect', this.emit.bind(this, 'reconnect'))\n  con.on('disconnect', this.emit.bind(this, 'disconnect'))\n  con.on('disconnect', this.emit.bind(this, 'offline'))\n  con.on('streamStart', function (attrs) {\n    if (attrs.to === undefined) {\n      this.connection.error('host-unknown', \"'to' attribute missing\")\n    } else if (attrs.to === '') {\n      this.connection.error('host-unknown', \"empty 'to' attibute\")\n    } else {\n      this.serverdomain = attrs.to\n      con.streamAttrs.from = attrs.to\n      this.startStream()\n    }\n  }.bind(this))\n}\n\nSession.prototype.send = function (stanza) {\n  if (stanza.root) stanza = stanza.root()\n  this.connection.send(stanza)\n}\n\nSession.prototype.pause = function () {\n  if (this.connection.pause) {\n    this.connection.pause()\n  }\n}\n\nSession.prototype.resume = function () {\n  if (this.connection.resume) {\n    this.connection.resume()\n  }\n}\n\nSession.prototype.end = function () {\n  this.connection.end()\n}\n\nSession.prototype.startStream = function () {\n  if (this.connection.startStream) {\n    this.connection.startStream()\n  }\n  this.sendFeatures()\n}\n\nSession.prototype.decode64 = function (encoded) {\n  return (new Buffer(encoded, 'base64')).toString('utf8')\n}\n\nSession.prototype.sendFeatures = function () {\n  // trilian requires features to be prefixed https://github.com/node-xmpp/node-xmpp-server/pull/125\n  var features = new Element('stream:features', {xmlns: NS_STREAMS, 'xmlns:stream': NS_STREAMS})\n  if (!this.authenticated) {\n    if (this.server && this.server.availableSaslMechanisms) {\n      // TLS\n      var opts = this.server.options\n      if (opts && opts.tls && !this.connection.isSecure) {\n        features\n          .c('starttls', { xmlns: this.connection.NS_XMPP_TLS })\n          .c('required')\n      }\n      this.mechanisms = this.server.getSaslMechanisms()\n    } else {\n      this.mechanisms = []\n    }\n\n    var mechanismsEl = features.c(\n      'mechanisms', { xmlns: NS_XMPP_SASL })\n    this.mechanisms.forEach(function (mech) {\n      mechanismsEl.c('mechanism').t(mech.prototype.name)\n    })\n  } else {\n    features.c('bind', { xmlns: NS_BIND })\n    features.c('session', { xmlns: NS_SESSION })\n  }\n  this.send(features)\n}\n\nSession.prototype.onStanza = function (stanza) {\n  if (this.jid) stanza.attrs.from = this.jid.toString()\n\n  if (stanza.is('starttls', this.connection.NS_XMPP_TLS)) {\n    var toSend = new Element(\n      'proceed', { xmlns: this.connection.NS_XMPP_TLS }\n    )\n    this.send(toSend)\n    this.connection.setSecure(this.server.credentials, true)\n  } else if (stanza.is('auth', NS_XMPP_SASL) || stanza.is('response', NS_XMPP_SASL)) {\n    this.onAuth(stanza)\n  } else if (stanza.is('iq') && stanza.getChild('query', NS_REGISTER)) {\n    this.onRegistration(stanza)\n  } else if (this.authenticated) {\n    this.onAuthStanza(stanza)\n  }\n}\n\nSession.prototype.onAuthStanza = function (stanza) {\n  var bind = stanza.getChild('bind', NS_BIND)\n  if (stanza.is('iq') &&\n    (stanza.attrs.type === 'set') &&\n    (bind)) {\n    this.onBind(stanza)\n  } else if (stanza.is('iq') &&\n    (stanza.attrs.type === 'set') &&\n    stanza.getChild('session', NS_SESSION)) {\n    this.onSession(stanza)\n  } else {\n    this.emit('stanza', stanza)\n  }\n}\n\nSession.prototype.sendAuthError = function (error) {\n  if (this.jid) {\n    this.emit('auth-failure', this.jid)\n  }\n  var message = error && error.message ? error.message : 'Authentication failure'\n  var type = error && error.type ? error.type : 'not-authorized'\n  this.send(new Element('failure', {\n    xmlns: NS_XMPP_SASL\n  })\n    .c(type).up()\n    .c('text').t(message))\n}\n\nSession.prototype.onAuth = function (stanza) {\n  var self = this\n\n  // if we havn't already decided for one method\n  if (!this.mechanism) {\n    var matchingMechs = this.mechanisms.filter(function (mech) {\n      return mech.prototype.name === stanza.attrs.mechanism\n    })\n\n    // TODO handle case where we are not able to match a sasl mechanism\n    this.mechanism = new matchingMechs[0]()\n\n    /**\n     * Authenticates a user\n     * @param  Object authRequest obejct with credentials like {user: 'bob', password: 'secret'}\n     */\n    this.mechanism.authenticate = function (user, cb) {\n      if (!user.saslmech) {\n        // attach sasl mechanism\n        user.saslmech = self.mechanism.name\n      }\n\n      if (user.jid) {\n        user.jid = new JID(user.jid)\n      } else {\n        user.jid = new JID(user.username, self.serverdomain.toString())\n      }\n      user.client = self\n\n      // emit event\n      self.emit('authenticate', user, cb)\n    }\n    this.mechanism.success = function (user) {\n      self.emit('auth-success', user.jid)\n      self.jid = user.jid\n      self.authenticated = true\n      self.send(new Element('success', { xmlns: NS_XMPP_SASL }))\n      // incoming stream restart\n      if (self.connection.startParser) {\n        self.connection.startParser()\n      }\n    }\n    this.mechanism.failure = function (error) {\n      self.sendAuthError(error)\n    }\n  }\n\n  if (this.mechanism) {\n    this.mechanism.manageAuth(stanza, this)\n  }\n}\n\nSession.prototype.onRegistration = function (stanza) {\n  var self = this\n  var register = stanza.getChild('query', NS_REGISTER)\n  var reply = new Element('iq', { type: 'result' })\n  if (stanza.attrs.id) {\n    reply.attrs.id = stanza.attrs.id\n  }\n\n  if (stanza.attrs.type === 'get') {\n    var instructions = 'Choose a username and password for use ' +\n      'with this service. '\n    reply.c('query', { xmlns: NS_REGISTER })\n      .c('instructions').t(instructions).up()\n      .c('username').up()\n      .c('password')\n    proceed()\n  } else if (stanza.attrs.type === 'set') {\n    var jid = new JID(register.getChildText('username'), this.server.options.domain)\n    this.emit('register', {\n      jid: jid,\n      username: register.getChildText('username'),\n      password: register.getChildText('password'),\n      client: self\n    }, function (error) {\n      if (!error) {\n        self.emit('registration-success', self.jid)\n      } else {\n        self.emit('registration-failure', jid)\n        reply.attrs.type = 'error'\n        reply\n          .c('error', {\n            code: '' + error.code,\n            type: error.type\n          })\n          .c(error.condition, {\n            xmlns: NS_STANZAS\n          }).up()\n          .c('text', {\n            xmlns: NS_STANZAS\n          })\n          .t(error.message)\n      }\n      proceed()\n    })\n  }\n\n  function proceed () {\n    self.send(reply)\n  }\n}\n\nSession.prototype.onBind = function (stanza) {\n  var self = this\n  var bind = stanza.getChild('bind', NS_BIND)\n  var resourceNode = bind.getChild('resource', NS_BIND)\n  var resource = resourceNode ? resourceNode.getText() : null\n\n  var sendBind = function (resource) {\n    if (!resource) {\n      resource = self.generateId()\n    }\n    self.jid.setResource(resource)\n\n    self.send(\n      new Element('iq', {\n        type: 'result',\n        id: stanza.attrs.id\n      })\n        .c('bind', { xmlns: NS_BIND })\n        .c('jid').t(self.jid.toString()))\n  }\n\n  var listenerCount = 0\n  if (typeof EventEmitter.listenerCount !== 'undefined') {\n    listenerCount = EventEmitter.listenerCount(self, 'bind')\n  } else {\n    listenerCount = this.listeners('bind').length\n  }\n  if (listenerCount > 0) {\n    self.emit('bind', resource, function (error, resource) {\n      if (error) {\n        var element = new Element('iq', {\n          type: 'error',\n          id: stanza.attrs.id\n        })\n          .c('error', { type: error.type })\n          .c(error.condition, { xmlns: NS_STANZAS })\n        if (error.text) {\n          element.t(error.text)\n        }\n        self.send(element)\n      } else {\n        sendBind(resource)\n      }\n    })\n  } else {\n    sendBind(resource)\n  }\n}\n\nSession.prototype.onSession = function (stanza) {\n  var result = new IQ({type: 'result', id: stanza.attrs.id})\n    .c('session', {xmlns: NS_SESSION})\n  this.send(result)\n  this.emit('online')\n}\n\nmodule.exports = Session\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/C2S/TCP/Server.js":"'use strict'\n\nvar util = require('util')\nvar tls = require('tls')\nvar net = require('net')\nvar fs = require('fs')\nvar C2SServer = require('../Server')\nvar serverStop = require('../../serverStop')\n\nvar TCP_PORT = 5222\n\n/**\n * params:\n *   options : port on which to listen to C2S connections\n *   options.port : xmpp tcp socket port\n *   options.domain : domain of xmpp server\n *   options.autostart : if we start listening at given port\n *   options.requestCert : expect a client certificate (see tls.createSecurePair for more)\n *   options.rejectUnauthorized : reject when client cert missmatches (see tls.createSecurePair for more)\n *   options.tls : wrapper object for tlc config\n *   options.tls.key : private key string\n *   options.tls.cert : certificate string\n *   options.tls.keyPath : path to key\n *   options.tls.certPath : path to certificate\n */\nfunction TCPServer (options) {\n  var server = this.server = serverStop(options && options.server || net.createServer())\n  server.on('connection', this.acceptConnection.bind(this))\n  server.on('close', this.emit.bind(this, 'close'))\n  server.on('error', this.emit.bind(this, 'error'))\n  server.on('listening', this.emit.bind(this, 'listening'))\n\n  C2SServer.call(this, options)\n  this._setupTls()\n}\n\nutil.inherits(TCPServer, C2SServer)\n\nTCPServer.prototype.DEFAULT_PORT = TCP_PORT\n\nTCPServer.prototype._setupTls = function () {\n  if (!this.options.tls) return\n  var details = this.options.tls\n  details.key = details.key || fs.readFileSync(details.keyPath, 'ascii')\n  details.cert = details.cert || fs.readFileSync(details.certPath, 'ascii')\n  this.credentials = tls.createSecureContext(details)\n}\n\nmodule.exports = TCPServer\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/C2S/WebSocket/Server.js":"'use strict'\n\nvar util = require('util')\nvar http = require('http')\nvar ws = require('ws')\nvar Socket = require('./Socket')\nvar C2SServer = require('../Server')\nvar serverStop = require('../../serverStop')\n\nvar WEBSOCKET_PORT = 5290\nvar XMPP_FRAMING = 'urn:ietf:params:xml:ns:xmpp-framing'\n\nfunction WebSocketServer (opts) {\n  var options = opts || {}\n  var server = this.server = serverStop(options.server || http.createServer())\n  server.on('close', this.emit.bind(this, 'close'))\n  server.on('error', this.emit.bind(this, 'error'))\n  server.on('listening', this.emit.bind(this, 'listening'))\n\n  var WS = this.WS = new ws.Server({server: server})\n  var self = this\n  WS.on('connection', function (socket) {\n    self.acceptConnection(new Socket(socket))\n  })\n\n  options.streamOpen = 'open'\n  options.streamClose = 'close'\n  options.streamAttrs = {'xmlns': XMPP_FRAMING}\n\n  C2SServer.call(this, options)\n}\n\nutil.inherits(WebSocketServer, C2SServer)\n\nWebSocketServer.prototype.DEFAULT_PORT = WEBSOCKET_PORT\n\nmodule.exports = WebSocketServer\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/C2S/WebSocket/Socket.js":"'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar debug = require('debug')('xmpp:server:websocket')\nvar ltx = require('node-xmpp-core').ltx\n\nfunction Socket (socket) {\n  EventEmitter.call(this)\n\n  this.xmlns = {}\n  this.websocket = null\n\n  this.writable = true\n  this.readable = true\n  this.setupSocket(socket)\n}\nutil.inherits(Socket, EventEmitter)\n\nSocket.prototype.maxStanzaSize = 65535\n\nSocket.prototype.setupSocket = function (socket) {\n  debug('set socket')\n  this.socket = socket\n  var self = this\n\n  socket.on('open', function () {\n    debug('websocket connected')\n  })\n\n  socket.on('close', function () {\n    debug('websocket disconnected')\n    self.emit('close')\n  })\n\n  socket.on('message', function (message, flags) {\n    var connection = self.session.connection\n    var body\n\n    if (flags && (flags.binary || flags.masked)) {\n      body = message.toString('utf8')\n    } else {\n      body = message\n    }\n\n    var stanza\n    try {\n      stanza = ltx.parse(body)\n    } catch (e) {\n      console.log(e)\n      connection.error('xml-not-well-formed', 'XML parse error')\n      return\n    }\n\n    if (stanza.is('open')) {\n      connection.emit('streamStart', stanza.attrs)\n    } else {\n      connection.emit('stanza', stanza)\n    }\n  })\n\n  socket.on('error', function () {\n    debug('websocket error')\n    self.emit('error')\n  })\n}\n\nSocket.prototype.serializeStanza = function (stanza, fn) {\n  fn(stanza.toString()) // No specific serialization\n}\n\nSocket.prototype.write = function (data) {\n  debug(data)\n  var self = this\n  this.socket.send(data, function (error) {\n    if (error) {\n      self.emit('error', error)\n    }\n  })\n}\n\nSocket.prototype.pause = function () {\n  // nothing to do\n  debug('websocket is requested to pause. But we cannot do anything')\n}\n\nSocket.prototype.resume = function () {\n  // nothing to do\n  debug('websocket is requested to resume. But we cannot do anything')\n}\n\nSocket.prototype.end = function () {\n  debug('close connection')\n  this.socket.close()\n  this.emit('end')\n}\n\nmodule.exports = Socket\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/component/Server.js":"'use strict'\n\nvar util = require('util')\nvar net = require('net')\nvar Server = require('../Server')\nvar Session = require('./Session')\n\nvar COMPONENT_PORT = 5347\n\n/**\n * params:\n *   options : port on which to listen to component connections\n *   options.port : xmpp tcp socket port\n *   options.autostart : if we start listening at given port\n */\nfunction ComponentServer (options) {\n  var server = this.server = (options && options.server || net.createServer())\n  server.on('connection', this.acceptConnection.bind(this))\n  server.on('close', this.emit.bind(this, 'close'))\n  server.on('error', this.emit.bind(this, 'error'))\n  server.on('listening', this.emit.bind(this, 'listening'))\n\n  Server.call(this, options)\n}\n\nutil.inherits(ComponentServer, Server)\n\nComponentServer.prototype.Session = Session\n\nComponentServer.prototype.DEFAULT_PORT = COMPONENT_PORT\n\nmodule.exports = ComponentServer\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/component/Session.js":"'use strict'\n\nvar util = require('util')\nvar crypto = require('crypto')\nvar EventEmitter = require('events').EventEmitter\nvar Connection = require('node-xmpp-core').Connection\nvar JID = require('node-xmpp-core').JID\nvar Element = require('node-xmpp-core').Element\n\nfunction ComponentSession (opts) {\n  EventEmitter.call(this)\n  this.connection = opts.connection || new Connection()\n  this._addConnectionListeners()\n  this.connection.xmlns[''] = this.NS_COMPONENT\n  this.connection.xmlns.stream = this.NS_STREAM\n  if (this.connection.connect) {\n    this.connection.connect({socket: opts.socket})\n  }\n}\n\nutil.inherits(ComponentSession, EventEmitter)\n\nComponentSession.prototype.NS_COMPONENT = 'jabber:component:accept'\nComponentSession.prototype.NS_STREAM = 'http://etherx.jabber.org/streams'\n\nComponentSession.prototype.onStreamStart = function (streamAttrs) {\n  if (streamAttrs.xmlns !== this.NS_COMPONENT) {\n    this.connection.error('invalid-namespace', \"invalid namespace '\" + streamAttrs.xmlns + \"'\")\n    return\n  }\n\n  var self = this\n  this.jid = new JID(streamAttrs.to)\n  this.emit('verify-component', this.jid, function (err, password) {\n    if (err) {\n      self.connection.error('host-unknown', err.message || 'unknown host')\n    } else {\n      if (!streamAttrs.id) streamAttrs.id = Date.now()\n      self.expectedDigest = self._sha1Hex((streamAttrs.id || '') + password)\n      self.connection.streamAttrs = streamAttrs\n      self.connection.startStream()\n    }\n  })\n}\n\nComponentSession.prototype.onStanza = function (stanza) {\n  if (!stanza.is('handshake')) {\n    this.emit('stanza', stanza)\n    return\n  }\n\n  if (stanza.getText() === this.expectedDigest) {\n    this.emit('auth-success')\n    this.connection.send(new Element('handshake'))\n    this.emit('online')\n    this.authenticated = true\n  } else {\n    this.connection.error('not-authorized', 'not authorized')\n  }\n}\n\nComponentSession.prototype.send = function (stanza) {\n  this.connection.send(stanza)\n}\n\nComponentSession.prototype.end = function () {\n  this.connection.end()\n}\n\nComponentSession.prototype._addConnectionListeners = function (con) {\n  con = con || this.connection\n  con.on('streamStart', this.onStreamStart.bind(this))\n  con.on('stanza', this.onStanza.bind(this))\n  con.on('drain', this.emit.bind(this, 'drain'))\n  con.on('data', this.emit.bind(this, 'data'))\n  con.on('end', this.emit.bind(this, 'end'))\n  con.on('close', this.emit.bind(this, 'close'))\n  con.on('error', this.emit.bind(this, 'error'))\n  con.on('connect', this.emit.bind(this, 'connect'))\n  con.on('reconnect', this.emit.bind(this, 'reconnect'))\n  con.on('disconnect', this.emit.bind(this, 'disconnect'))\n  con.on('disconnect', this.emit.bind(this, 'offline'))\n}\n\nComponentSession.prototype._sha1Hex = function (s) {\n  var hash = crypto.createHash('sha1')\n  hash.update(s)\n  return hash.digest('hex')\n}\n\nmodule.exports = ComponentSession\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/S2S/Router.js":"'use strict'\n\n/*\n * Implements http://tools.ietf.org/html/rfc3920#section-14.4\n */\nvar fs = require('fs')\nvar net = require('net')\nvar util = require('util')\nvar tls = require('tls')\nvar EventEmitter = require('events').EventEmitter\nvar rack = require('hat').rack\nvar JID = require('node-xmpp-core').JID\nvar DomainContext = require('./domaincontext')\nvar nameprep = require('./util/nameprep')\nvar dialbackkey = require('./util/dialbackkey')\nvar IncomingServer = require('./session/incoming')\nvar debug = require('debug')('xmpp:s2s:router')\n\n/**\n * Accepts incoming S2S connections. Handles routing of outgoing\n * stanzas, and allows you to register a handler\n * for your own domain.\n */\nfunction Router (s2sPort, bindAddress, opts) {\n  EventEmitter.call(this)\n  this.ctxs = {}\n\n  opts = opts || {}\n\n  this.generateId = rack(opts.idBits, opts.idBitsBase, opts.idBitsExpandBy)\n\n  if (opts.secureDomains && opts.secureDomains.length) {\n    opts.secureDomains.forEach(this.addSecureDomain, this)\n  }\n\n  // start tcp socket\n  this._server = net.createServer(function (socket) {\n    this.acceptConnection(socket)\n  }.bind(this)).listen(s2sPort || 5269, bindAddress || '::')\n}\n\nutil.inherits(Router, EventEmitter)\n\n// Defaults\nRouter.prototype.rateLimit = 100 // 100 KB/s, it's S2S after all\nRouter.prototype.maxStanzaSize = 65536 // 64 KB, by convention\nRouter.prototype.keepAlive = 30 * 1000 // 30s\nRouter.prototype.streamTimeout = 5 * 60 * 1000 // 5min\nRouter.prototype.credentials = {} // TLS credentials per domain\n\nRouter.prototype.close = function (callback) {\n  debug('closing server')\n  this._server.close(callback)\n}\n\n/*\n * little helper, because dealing with crypto & fs gets unwieldy\n */\nRouter.prototype.loadCredentials = function (domain, key, cert, ca) {\n  var creds = {\n    key: key,\n    cert: cert,\n    ca: ca\n  }\n  this.getContext(domain).setCredentials(tls.createSecureContext(creds))\n}\n\nRouter.prototype.loadCredentialsFromFile = function (domain, keyPath, certPath, caPath) {\n  var key = fs.readFileSync(keyPath, 'ascii')\n  var cert = fs.readFileSync(certPath, 'ascii')\n  var ca = caPath ? fs.readFileSync(caPath, 'ascii') : undefined\n\n  this.loadCredentials(domain, key, cert, ca)\n}\n\nRouter.prototype.addSecureDomain = function (domain) {\n  this.getContext(nameprep(domain)).secureDomain = true\n}\n\n/*\n * handles a new socket connection\n */\nRouter.prototype.acceptConnection = function (socket) {\n  debug('accept a new connection' + socket)\n  var self = this\n\n  var inStream = new IncomingServer({\n    streamId: this.generateId(),\n    reconnect: false,\n    requestCert: true,\n    socket: socket\n  })\n\n  // send features supported by this domain\n  inStream.on('streamStart', function (attrs) {\n    inStream.fromDomain = nameprep(attrs.from)\n    inStream.toDomain = nameprep(attrs.to)\n    var domainContext = self.getContext(inStream.toDomain)\n    var credentials = domainContext.credentials\n    if (credentials) {\n      inStream.opts.tls = true\n      inStream.credentials = credentials\n      inStream.secureDomain = domainContext.secureDomain\n    }\n    inStream.sendFeatures()\n  })\n\n  inStream.on('auth', function (type) {\n    if (type === 'SASL') {\n      inStream.onSASLAuth()\n    }\n    self.getContext(inStream.toDomain).addInStream(inStream.fromDomain, inStream)\n  })\n\n  // incoming server wants to verify an outgoing connection of ours\n  inStream.on('dialbackVerify', function (from, to, id, key) {\n    from = nameprep(from)\n    to = nameprep(to)\n    if (self.hasContext(to)) {\n      self.getContext(to).verifyDialback(from, id, key, function (isValid) {\n        // look if this was a connection of ours\n        inStream.send(dialbackkey.dialbackVerified(to, from, id, isValid))\n      })\n    } else {\n      // we don't host the 'to' domain\n      inStream.send(dialbackkey.dialbackVerified(to, from, id, false))\n    }\n  })\n\n  // incoming connection wants to get verified\n  inStream.on('dialbackKey', function (from, to, key) {\n    from = nameprep(from)\n    to = nameprep(to)\n    if (self.hasContext(to)) {\n      // trigger verification via outgoing connection\n      self.getContext(to).verifyIncoming(from, inStream, key)\n    } else {\n      inStream.error('host-unknown', to + ' is not served here')\n    }\n  })\n  return inStream\n}\n\n/**\n * Create domain context & register a stanza listener callback\n */\nRouter.prototype.register = function (domain, listener) {\n  domain = nameprep(domain)\n  debug('register a new domain: ' + domain)\n  this.getContext(domain).stanzaListener = listener\n}\n\n/**\n * Unregister a context and stop its connections\n */\nRouter.prototype.unregister = function (domain) {\n  debug('unregister a domain: ' + domain)\n  if (this.hasContext(domain)) {\n    this.ctxs[domain].end()\n\n    delete this.ctxs[domain]\n  }\n}\n\nRouter.prototype.send = function (stanza) {\n  debug('send: ' + stanza.root().toString())\n\n  if (stanza.root) {\n    stanza = stanza.root()\n  }\n\n  var to = stanza.attrs && stanza.attrs.to\n  var toDomain = to && (new JID(to)).getDomain()\n  if (toDomain && this.hasContext(toDomain)) {\n    debug('inner routing')\n    // inner routing\n    this.getContext(toDomain).receive(stanza)\n  } else if (stanza.attrs && stanza.attrs.from) {\n    debug('s2s routing')\n    // route to domain context for s2s\n    var domain = (new JID(stanza.attrs.from)).getDomain()\n    this.getContext(domain).send(stanza)\n  } else {\n    throw new Error('Sending stanza from a domain we do not host')\n  }\n}\n\nRouter.prototype.hasContext = function (domain) {\n  return this.ctxs.hasOwnProperty(domain)\n}\n\nRouter.prototype.getContext = function (domain) {\n  if (this.ctxs.hasOwnProperty(domain)) {\n    return this.ctxs[domain]\n  } else {\n    this.ctxs[domain] = new DomainContext(this, domain)\n    return this.ctxs[domain]\n  }\n}\n\nmodule.exports = Router\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/S2S/domaincontext.js":"'use strict'\n\nvar JID = require('node-xmpp-core').JID\nvar Element = require('node-xmpp-core').Element\nvar nameprep = require('./util/nameprep')\nvar dialbackkey = require('./util/dialbackkey')\nvar OutgoingServer = require('./session/outgoing')\nvar debug = require('debug')('xmpp:s2s:domainctx')\n\nvar NS_XMPP_SASL = 'urn:ietf:params:xml:ns:xmpp-sasl'\nvar NS_XMPP_STANZAS = 'urn:ietf:params:xml:ns:xmpp-stanzas'\n\n/**\n * Represents a domain we host with connections to federated servers\n */\nfunction DomainContext (router, domain) {\n  // own domains\n  this.domain = domain\n\n  // attached routers\n  this.router = router\n\n  // store certificate\n  this.credentials = null\n\n  // s2s connections\n  this.s2sIn = {}\n  this.s2sOut = {}\n}\n\n/**\n * stores the credentials per domain\n */\nDomainContext.prototype.setCredentials = function (credentials) {\n  this.credentials = credentials\n}\n\n/**\n * Buffers until stream has been verified via Dialback\n */\nDomainContext.prototype.send = function (stanza) {\n  if (stanza.root) {\n    stanza = stanza.root()\n  }\n\n  // no destination? return to ourself\n  if (!stanza.attrs.to) {\n    // do not provoke ping-pong effects\n    if (stanza.attrs.type === 'error') {\n      return\n    }\n\n    stanza.attrs.to = stanza.attrs.from\n    delete stanza.attrs.from\n    stanza.attrs.type = 'error'\n    stanza.c('error', {\n      type: 'modify'\n    }).c('jid-malformed', {\n      xmlns: NS_XMPP_STANZAS\n    })\n    this.receive(stanza)\n\n    return\n  }\n\n  // route stanza\n  var destDomain = new JID(stanza.attrs.to).domain\n  // get stream for suiteable s2s connection\n  var outStream = this.getOutStream(destDomain)\n\n  if (outStream.isAuthed) {\n    outStream.send(stanza)\n  } else {\n    debug('queue the message')\n    // TODO: queues per domain in domaincontext\n    outStream.queue = outStream.queue || []\n    outStream.queue.push(stanza)\n  }\n}\n\n/**\n * Does only buffer until stream is established, used for Dialback\n * communication itself.\n *\n * returns the stream\n */\nDomainContext.prototype.sendRaw = function (stanza, destDomain) {\n  if (stanza.root) {\n    stanza = stanza.root()\n  }\n\n  var outStream = this.getOutStream(destDomain)\n  var send = function () {\n    outStream.send(stanza)\n  }\n\n  if (outStream.isConnected) {\n    send()\n  } else {\n    outStream.once('online', send)\n  }\n\n  return outStream\n}\n\n/*\n * establishes a new S2S connection\n */\nDomainContext.prototype.establishS2SStream = function (destDomain) {\n  debug('establish a new S2S stream')\n  var self = this\n\n  // Setup a new outgoing connection\n  var outStream = new OutgoingServer(this.domain, destDomain, this.credentials)\n  this.s2sOut[destDomain] = outStream\n  this.setupStream(destDomain, outStream)\n\n  var closeCb = function () {\n    // purge queue\n    if (outStream.queue) {\n      outStream.queue.forEach(function (stanza) {\n        // do not provoke ping-pong effects\n        if (stanza.attrs.type === 'error') {\n          return\n        }\n\n        var dest = stanza.attrs.to\n        stanza.attrs.to = stanza.attrs.from\n        stanza.attrs.from = dest\n        stanza.attrs.type = 'error'\n        stanza.c('error', {\n          type: 'cancel'\n        }).c('remote-server-not-found', {\n          xmlns: NS_XMPP_STANZAS\n        })\n        self.receive(stanza)\n      })\n    }\n    delete outStream.queue\n\n    // remove from DomainContext\n    delete self.s2sOut[destDomain]\n  }\n  outStream.on('close', closeCb)\n  outStream.on('error', closeCb)\n\n  var onAuth = function (method) {\n    debug('onAuth')\n    outStream.isConnected = true\n    switch (method) {\n      case 'dialback':\n        self.startDialback(destDomain, outStream)\n        break\n\n      case 'external':\n        outStream.send(new Element('auth', {\n          xmlns: NS_XMPP_SASL,\n          mechanism: 'EXTERNAL'\n        }).t(new Buffer(self.domain).toString('base64')))\n        var onStanza\n        onStanza = function (stanza) {\n          if (stanza.is('success', NS_XMPP_SASL)) {\n            outStream.startStream()\n            outStream.removeListener('stanza', onStanza)\n            var onStream\n            onStream = function () {\n              outStream.emit('online')\n              outStream.removeListener('streamStart', onStream)\n            }\n            outStream.on('streamStart', onStream)\n          } else if (stanza.is('failure', NS_XMPP_SASL)) {\n            outStream.end()\n          }\n        }\n        outStream.on('stanza', onStanza)\n        break\n\n      default:\n        outStream.error('undefined-condition',\n          'Cannot authenticate via ' + method)\n    }\n    outStream.removeListener('auth', onAuth)\n  }\n  outStream.on('auth', onAuth)\n\n  outStream.on('online', function () {\n    debug('online')\n    outStream.isAuthed = true\n    if (outStream.queue) {\n      outStream.queue.forEach(function (stanza) {\n        outStream.send(stanza)\n      })\n      delete outStream.queue\n    }\n  })\n\n  return outStream\n}\n\n/**\n * Establish outgoing stream on demand\n * @param string destdomain domain of a jid\n */\nDomainContext.prototype.getOutStream = function (destDomain) {\n  // according to the spec we cannot use the incoming streams\n\n  if (!destDomain) {\n    throw new Error('Trying to reach empty domain')\n  // There's one already\n  } else if (this.s2sOut.hasOwnProperty(destDomain)) {\n    return this.s2sOut[destDomain]\n  // establish a new connection\n  } else {\n    return this.establishS2SStream(destDomain)\n  }\n}\n\n/**\n * Called by router when verification is done\n */\nDomainContext.prototype.addInStream = function (srcDomain, stream) {\n  var self = this\n\n  if (this.s2sIn.hasOwnProperty(srcDomain)) {\n    // Replace old\n    var oldStream = this.s2sIn[srcDomain]\n    oldStream.error('conflict', 'Connection replaced')\n    delete self.s2sIn[srcDomain]\n  }\n\n  // check if we have the tls certificate\n  if (this.credentials) {\n    stream.credentials = this.credentials\n    stream.opts.tls = true\n  }\n\n  this.setupStream(srcDomain, stream)\n  stream.isConnected = true\n  stream.isAuthed = true\n  var closeCb = function () {\n    if (self.s2sIn[srcDomain] === stream) {\n      delete self.s2sIn[srcDomain]\n    }\n  }\n  stream.on('close', closeCb)\n  stream.on('error', closeCb)\n  this.s2sIn[srcDomain] = stream\n}\n\nDomainContext.prototype.setupStream = function (domain, stream) {\n  debug('setup new stream')\n  var self = this\n\n  stream.on('stanza', function (stanza) {\n    // Before verified they can send whatever they want\n    if (!stream.isAuthed) {\n      return\n    }\n\n    if (stanza.name !== 'message' &&\n      stanza.name !== 'presence' &&\n      stanza.name !== 'iq') {\n      // no normal stanza\n      return\n    }\n\n    if (!(typeof stanza.attrs.from === 'string' &&\n      typeof stanza.attrs.to === 'string')) {\n      stream.error('improper-addressing')\n      return\n    }\n\n    // Only accept 'from' attribute JIDs that have the same domain\n    // that we validated the stream for\n    var fromDomain = (new JID(stanza.attrs.from)).domain\n    if (fromDomain !== domain) {\n      stream.error('invalid-from')\n      return\n    }\n\n    // Only accept 'to' attribute JIDs to this DomainContext\n    var toDomain = (new JID(stanza.attrs.to)).domain\n    if (toDomain !== self.domain) {\n      stream.error('improper-addressing')\n      return\n    }\n\n    self.receive(stanza)\n  })\n}\n\n/*\n * we want to get our outgoing connection verified, sends <db:result/>\n */\nDomainContext.prototype.startDialback = function (destDomain, outStream) {\n  debug('start a dialback')\n  outStream.dbKey = dialbackkey.generateHMAC(this.domain, destDomain, outStream.streamId)\n  outStream.send(dialbackkey.dialbackKey(this.domain, destDomain, outStream.dbKey))\n\n  var self = this\n  var onResult = function (from, to, isValid) {\n    if ((from !== destDomain) ||\n      (to !== self.domain)) {\n      // not for us\n      return\n    }\n\n    outStream.removeListener('dialbackResult', onResult)\n    if (isValid) {\n      outStream.emit('online')\n    } else {\n      // we cannot do anything else with this stream that\n      // failed dialback\n      outStream.end()\n    }\n  }\n  outStream.on('dialbackResult', onResult)\n}\n\n/*\n * incoming verification request for our outgoing connection that came\n * in via an inbound server connection\n */\nDomainContext.prototype.verifyDialback = function (domain, id, key, cb) {\n  var self = this\n  var outStream\n  if (this.s2sOut.hasOwnProperty(domain) &&\n    (outStream = this.s2sOut[domain])) {\n    if (outStream.isConnected) {\n      debug('verify key:' + outStream.dbKey + ' ' + key)\n      debug('compare id:' + outStream.streamId + ' ' + id)\n      var isValid = outStream.streamId === id &&\n        outStream.dbKey === key\n      cb(isValid)\n    } else {\n      // Not online, wait for outStream.streamAttrs\n      // (they may have our stream header & dialback key, but\n      // our slow connection hasn't received their stream\n      // header)\n      outStream.on('online', function () {\n        // recurse\n        self.verifyDialback(domain, id, key, cb)\n      })\n      outStream.on('close', function () {\n        cb(false)\n      })\n    }\n  } else {\n    cb(false)\n  }\n}\n\nDomainContext.prototype.verifyIncoming = function (fromDomain, inStream, dbKey) {\n  var self = this\n  debug('verify incoming streamid: ' + inStream.streamId)\n  var outStream = this.sendRaw(dialbackkey.dialbackVerify(this.domain, fromDomain,\n    inStream.streamId, dbKey),\n    fromDomain)\n\n  // these are needed before for removeListener()\n  var onVerified = function (from, to, id, isValid) {\n    from = nameprep(from)\n    to = nameprep(to)\n    if ((from !== fromDomain) ||\n      (to !== self.domain) ||\n      (id !== inStream.streamId)) {\n      // not for us\n      return\n    }\n    // tell them about it\n    inStream.send(dialbackkey.dialbackResult(to, from, isValid))\n\n    if (isValid) {\n      // finally validated them!\n      self.addInStream(from, inStream)\n    } else {\n      // the connection isn't used for another domain, so\n      // closing is safe\n      inStream.send('</stream:stream>')\n      inStream.end()\n    }\n\n    rmCbs()\n  }\n  var onClose = function () {\n    // outgoing connection didn't work out, tell the incoming\n    // connection\n    inStream.send(dialbackkey.dialbackResult(self.domain, fromDomain, false))\n\n    rmCbs()\n  }\n  var onCloseIn = function () {\n    // t'was the incoming stream that wanted to get\n    // verified, nothing to do remains\n\n    rmCbs()\n  }\n  var rmCbs = function () {\n    outStream.removeListener('dialbackVerified', onVerified)\n    outStream.removeListener('close', onClose)\n    inStream.removeListener('close', onCloseIn)\n  }\n  outStream.on('dialbackVerified', onVerified)\n  outStream.on('close', onClose)\n  inStream.on('close', onCloseIn)\n}\n\nDomainContext.prototype.receive = function (stanza) {\n  if (this.stanzaListener) {\n    this.stanzaListener(stanza)\n  }\n}\n\nDomainContext.prototype.end = function () {\n  debug('close connection')\n  var shutdown = function (conns) {\n    for (var domain in conns) {\n      if (conns.hasOwnProperty(domain)) {\n        conns[domain].end()\n      }\n    }\n  }\n  shutdown(this.s2sOut)\n  shutdown(this.s2sIn)\n}\n\nmodule.exports = DomainContext\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/S2S/util/nameprep.js":"'use strict'\n\nvar nameprep\ntry {\n  var StringPrep = require('node-stringprep').StringPrep\n  var c = function (n) {\n    var p = new StringPrep(n)\n    return function (s) {\n      return p.prepare(s)\n    }\n  }\n  nameprep = c('nameprep')\n} catch (ex) {\n  nameprep = function (a) {\n    return a\n  }\n}\n\nmodule.exports = nameprep\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/S2S/util/dialbackkey.js":"'use strict'\n\nvar Element = require('node-xmpp-core').Element\nvar crypto = require('crypto')\nvar debug = require('debug')('xmpp:s2s:util:dialbackkey')\n\n/*\n * Returns the stanzas as defined in XEP-0185\n *\n * http://xmpp.org/extensions/xep-0185.html\n */\nfunction DialbackKey () {\n  this.secret = crypto.randomBytes(256).toString('hex')\n}\n\n/**\n * generate hmac according to http://xmpp.org/extensions/xep-0185.html\n */\nDialbackKey.prototype.generateHMAC = function (recievingsrv, originatingsrv, streamid) {\n  var shasum = crypto.createHash('sha256')\n  shasum.update(this.secret)\n  var shakey = shasum.digest('hex')\n  var text = recievingsrv + ' ' + originatingsrv + ' ' + streamid\n  var hash = crypto.createHmac('sha256', shakey).update(text).digest('hex')\n  debug(hash)\n  return hash\n}\n\nDialbackKey.prototype.dialbackKey = function (from, to, key) {\n  return new Element('db:result', {\n    to: to,\n    from: from\n  }).t(key)\n}\n\nDialbackKey.prototype.dialbackVerify = function (from, to, id, key) {\n  return new Element('db:verify', {\n    to: to,\n    from: from,\n    id: id\n  }).t(key)\n}\n\nDialbackKey.prototype.dialbackVerified = function (from, to, id, isValid) {\n  return new Element('db:verify', {\n    to: to,\n    from: from,\n    id: id,\n    type: isValid ? 'valid' : 'invalid'\n  })\n}\n\nDialbackKey.prototype.dialbackResult = function (from, to, isValid) {\n  return new Element('db:result', {\n    to: to,\n    from: from,\n    type: isValid ? 'valid' : 'invalid'\n  })\n}\n\nmodule.exports = new DialbackKey()\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/S2S/session/outgoing.js":"'use strict'\n\nvar util = require('util')\nvar SRV = require('node-xmpp-core').SRV\nvar Connection = require('node-xmpp-core').Connection\nvar Server = require('./server')\nvar debug = require('debug')('xmpp:s2s:outserver')\nvar NS_XMPP_SASL = 'urn:ietf:params:xml:ns:xmpp-sasl'\n\nvar OutgoingServer = function (srcDomain, destDomain, credentials) {\n  debug(util.format('establish an outgoing S2S connection from %s to %s', srcDomain, destDomain))\n\n  this.streamId = null\n\n  var streamAttrs = {\n    version: '1.0',\n    from: srcDomain\n  }\n\n  this.streamTo = destDomain\n\n  // For outgoing, we only need our own cert & key\n  this.credentials = credentials\n\n  // No credentials means we cannot <starttls/> on the server\n  // side. Unfortunately this is required for XMPP 1.0.\n  if (!this.credentials) {\n    delete this.xmppVersion\n    this.allowTLS = false\n  }\n\n  this.on('streamStart', function (attrs) {\n    // extract stream id\n    this.streamId = attrs.id\n  })\n\n  Server.call(this, {streamAttrs: streamAttrs})\n\n  // establish connection\n  this.listen({\n    socket: SRV.connect({\n      services: ['_xmpp-server._tcp', '_jabber._tcp'],\n      domain: destDomain,\n      defaultPort: 5269\n    })\n  })\n}\n\nutil.inherits(OutgoingServer, Server)\n\nfunction hasSASLExternal (stanza) {\n  var mechanisms = stanza.getChild('mechanisms', NS_XMPP_SASL)\n  if (mechanisms) {\n    var mechanism = mechanisms.getChild('mechanism')\n    return mechanism && mechanism.text() === 'EXTERNAL'\n  }\n  return false\n}\n\n// overwrite onStanza from Server\nOutgoingServer.prototype.onStanza = function (stanza) {\n  debug('recieved stanza' + stanza.toString())\n  var handled = Server.prototype.onStanza.call(this, stanza)\n\n  if (!handled) {\n    if (stanza.is('features', Connection.NS_STREAM)) {\n      debug('send features')\n      if (hasSASLExternal(stanza)) {\n        this.emit('auth', 'external')\n      } else {\n        this.emit('auth', 'dialback')\n      }\n    } else {\n      this.emit('stanza', stanza)\n    }\n\n    this.handleDialback(stanza)\n  }\n}\n\nmodule.exports = OutgoingServer\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/S2S/session/server.js":"'use strict'\n\n/**\n * Implements http://xmpp.org/extensions/xep-0220.html\n */\nvar util = require('util')\nvar ltx = require('node-xmpp-core').ltx\nvar Connection = require('node-xmpp-core').Connection\nvar StreamShaper = require('../stream/shaper')\nvar IdleTimeout = require('../stream/timeout')\nvar debug = require('debug')('xmpp:s2s:server')\n\nvar NS_SERVER = 'jabber:server'\nvar NS_DIALBACK = 'jabber:server:dialback'\n\n/**\n * Dialback-specific events:\n * (1) dialbackKey(from, to, key)\n * (2) dialbackVerify(from, to, id, key)\n * (3) dialbackVerified(from, to, id, isValid)\n * (4) dialbackResult(from, to, isValid)\n */\nfunction Server (opts) {\n  this.opts = opts || {}\n  Connection.call(this, opts)\n\n  this.xmlns[''] = NS_SERVER\n  this.xmlns.db = NS_DIALBACK\n  this.xmppVersion = '1.0'\n\n  // Clients start <stream:stream>, servers reply\n  this.on('connect', this.streamStart.bind(this))\n}\nutil.inherits(Server, Connection)\n\nServer.prototype.NS_SERVER = NS_SERVER\nServer.prototype.NS_DIALBACK = NS_DIALBACK\n\nServer.prototype.setupStream = function (opts) {\n  debug('setup stream')\n\n  Connection.prototype.setupStream.call(this, opts)\n\n  this.on('connect', function (socket) {\n    StreamShaper.attach(socket, this.rateLimit)\n    socket.setKeepAlive(true, this.keepAlive)\n    IdleTimeout.attach(socket, this.streamTimeout)\n    socket.on('timeout', function () {\n      if (this.socket === socket) {\n        this.error('connection-timeout')\n      }\n    })\n  }.bind(this))\n}\n\nServer.prototype.streamStart = function (opts) {\n  Connection.prototype.startStream.call(this, opts)\n}\n\nfunction getAllText (el) {\n  return !el.children ? el : el.children.reduce(function (text, child) {\n    return text + getAllText(child)\n  }, '')\n}\n\n// overwrite onStanza from Connection\nServer.prototype.onStanza = function (stanza) {\n  var handled = false\n\n  if (stanza.is('error', this.NS_STREAM)) {\n    var error = new Error('' + getAllText(stanza))\n    error.stanza = stanza\n    this.socket.emit('error', error)\n    handled = true\n  } else if (stanza.is('features', this.NS_STREAM) &&\n    this.allowTLS &&\n    !this.isSecure &&\n    stanza.getChild('starttls', this.NS_XMPP_TLS)) {\n    /* Signal willingness to perform TLS handshake */\n    this.send(new ltx.Element('starttls', { xmlns: this.NS_XMPP_TLS }))\n    handled = true\n  } else if (this.allowTLS &&\n    stanza.is('proceed', this.NS_XMPP_TLS)) {\n    /* Server is waiting for TLS handshake */\n    this.setSecure()\n    handled = true\n  }\n\n  return handled\n}\n\nServer.prototype.handleDialback = function (stanza) {\n  var handled = false\n  var key = stanza.getText()\n\n  if (stanza.is('result', this.NS_DIALBACK)) {\n    if (stanza.attrs.from && stanza.attrs.to &&\n      stanza.attrs.type) {\n      debug('dialback result')\n      this.emit('dialbackResult',\n        stanza.attrs.from,\n        stanza.attrs.to, (stanza.attrs.type === 'valid')\n      )\n      handled = true\n    } else if (stanza.attrs.from && stanza.attrs.to) {\n      debug('dialback key')\n      this.emit('dialbackKey',\n        stanza.attrs.from,\n        stanza.attrs.to,\n        key\n      )\n      handled = true\n    }\n  } else if (stanza.is('verify', this.NS_DIALBACK)) {\n    if (stanza.attrs.from && stanza.attrs.to &&\n      stanza.attrs.id && stanza.attrs.type) {\n      debug('dialback verified')\n      this.emit('dialbackVerified',\n        stanza.attrs.from,\n        stanza.attrs.to,\n        stanza.attrs.id, (stanza.attrs.type === 'valid')\n      )\n      handled = true\n    } else if (stanza.attrs.from && stanza.attrs.to && stanza.attrs.id) {\n      debug('dialback verify')\n      this.emit('dialbackVerify',\n        stanza.attrs.from,\n        stanza.attrs.to,\n        stanza.attrs.id,\n        key\n      )\n      handled = true\n    }\n  }\n\n  return handled\n}\n\nmodule.exports = Server\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/S2S/stream/shaper.js":"'use strict'\n\n/**\n * This is extremely simple and unprecise.\n *\n * @param {Number} rateLimit B/ms or KB/s\n */\nexports.attach = function (stream, rateLimit) {\n  var timer\n  // makes it readjustable after attachment\n  stream.rateLimit = rateLimit\n  stream.on('data', function (data) {\n    if (timer) clearTimeout(timer)\n    stream.pause()\n    var sleep = Math.floor(data.length / stream.rateLimit)\n    timer = setTimeout(function () {\n      timer = undefined\n      stream.resume()\n    }, sleep)\n  })\n  stream.on('close', function () {\n    // don't let the last timeout inhibit node shutdown\n    if (timer) clearTimeout(timer)\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/S2S/stream/timeout.js":"'use strict'\n\n/**\n * Emulates stream.setTimeout() behaviour, but respects outgoing data\n * too.\n *\n * @param {Number} timeout Milliseconds\n */\nexports.attach = function (stream, timeout) {\n  var timer\n  var emitTimeout = function () {\n    timer = undefined\n    stream.emit('timeout')\n  }\n  var updateTimer = function () {\n    if (timer) clearTimeout(timer)\n    timer = setTimeout(emitTimeout, timeout)\n  }\n\n  var oldWrite = stream.write\n  stream.write = function () {\n    updateTimer()\n    oldWrite.apply(this, arguments)\n  }\n  var clear = function () {\n    if (timer) clearTimeout(timer)\n    if (stream.write !== oldWrite) stream.write = oldWrite\n    delete stream.clearTimer\n  }\n  stream.clearTimer = clear\n  stream.on('data', updateTimer)\n  stream.on('error', clear)\n  stream.on('close', clear)\n  stream.on('end', clear)\n}\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/S2S/session/incoming.js":"'use strict'\n\nvar util = require('util')\nvar Element = require('node-xmpp-core').Element\nvar hat = require('hat')\nvar debug = require('debug')('xmpp:s2s:inserver')\nvar Server = require('./server')\n\nvar NS_XMPP_SASL = 'urn:ietf:params:xml:ns:xmpp-sasl'\n\n/**\n * Accepts incomming server-to-server connections\n */\nvar IncomingServer = function (opts) {\n  debug('start a new incoming server connection')\n\n  opts = opts || {}\n\n  this.streamId = opts.streamId || hat(opts.sidBits, opts.sidBitsBase)\n\n  var streamAttrs = {}\n  streamAttrs.version = '1.0'\n  streamAttrs.id = this.streamId\n  opts.streamAttrs = streamAttrs\n\n  // TLS is activated in domaincontext.\n\n  Server.call(this, opts)\n\n  this.connect({socket: opts.socket})\n\n  return this\n}\n\nutil.inherits(IncomingServer, Server)\n\nIncomingServer.NS_XMPP_SASL = NS_XMPP_SASL\n\nIncomingServer.prototype.handleTlsNegotiation = function (stanza) {\n  if (stanza.is('starttls', this.NS_XMPP_TLS)) {\n    this.send(new Element('proceed', {\n      xmlns: this.NS_XMPP_TLS\n    }))\n    this.setSecure(this.credentials, true, this.fromDomain)\n    return true\n  }\n  return false\n}\n\n// overwrite onStanza from Server\nIncomingServer.prototype.onStanza = function (stanza) {\n  var handled = [\n    Server.prototype.onStanza,\n    this.handleTlsNegotiation,\n    this.handleDialback,\n    this.handleSASLExternal\n  ].some(function (stanzaHandler) {\n    return stanzaHandler.call(this, stanza)\n  }, this)\n\n  // emit stanza if it is not handled\n  if (!handled) {\n    this.emit('stanza', stanza)\n  }\n}\n\nIncomingServer.prototype.verifyCertificate = function () {\n  // authorized ?\n  var socket = this.socket\n  if (!socket.authorized) {\n    debug('certificate authorization failed: ' + socket.authorizationError)\n    return this.sendNotAuthorizedAndClose()\n  }\n\n  debug(this.fromDomain + ' authorized')\n  this.emit('auth', 'SASL')\n}\n\nIncomingServer.prototype.onSASLAuth = function () {\n  this.send(new Element('success', {\n    xmlns: NS_XMPP_SASL\n  }))\n  this.streamStart()\n}\n\nfunction isEmptyCertificate (certificate) {\n  return certificate == null || Object.keys(certificate).length === 0\n}\n\nfunction isSASLExternal (stanza) {\n  return stanza && stanza.is('auth', NS_XMPP_SASL) && stanza.attrs.mechanism && stanza.attrs.mechanism === 'EXTERNAL'\n}\n\nIncomingServer.prototype.handleSASLExternal = function (stanza) {\n  var self = this\n  if (this.isSecure && isSASLExternal(stanza)) {\n    debug('Auth using SASL EXTERNAL')\n\n    var certificate = this.socket.getPeerCertificate()\n\n    if (isEmptyCertificate(certificate)) {\n      debug('Empty certificate. Renegotiate for certificate.')\n      this.socket.renegotiate({requestCert: true}, function (error) {\n        if (error) {\n          return self.error('internal-server-error', error)\n        }\n        self.verifyCertificate()\n      })\n    } else {\n      self.verifyCertificate()\n    }\n    return true\n  }\n  return false\n}\n\nIncomingServer.prototype.sendNotAuthorizedAndClose = function () {\n  this.send(new Element('failure', {\n    xmlns: NS_XMPP_SASL\n  }).c('not-authorized').up()\n  )\n  this.closeStream()\n  this.end()\n}\n\nIncomingServer.prototype.sendFeatures = function () {\n  debug('send features')\n  var features = new Element('stream:features')\n  // TLS\n  if (this.opts && this.opts.tls && !this.isSecure) {\n    features\n      .c('starttls', {\n        xmlns: this.NS_XMPP_TLS\n      })\n      .c('required')\n  } else if (this.isSecure && this.secureDomain && !this.isAuthed) {\n    features.c('mechanisms', {\n      xmlns: NS_XMPP_SASL\n    })\n      .c('mechanism').t('EXTERNAL')\n  }\n  this.send(features)\n}\n\nmodule.exports = IncomingServer\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/C2S/authentication/DigestMD5.js":"'use strict'\n\nvar util = require('util')\nvar crypto = require('crypto')\nvar Element = require('node-xmpp-core').Element\nvar Mechanism = require('./Mechanism')\nvar JID = require('node-xmpp-core').JID\n\n/**\n * Hash a string\n */\nfunction md5 (s, encoding) {\n  var hash = crypto.createHash('md5')\n  hash.update(s, 'binary')\n  return hash.digest(encoding || 'binary')\n}\nfunction md5Hex (s) {\n  return md5(s, 'hex')\n}\n\n/**\n * Parse SASL serialization\n */\nfunction parseDict (s) {\n  var result = {}\n  while (s) {\n    var m\n    if ((m = /^(.+?)=(.*?[^\\\\]),\\s*(.*)/.exec(s))) {\n      result[m[1]] = m[2].replace(/\"/g, '')\n      s = m[3]\n    } else if ((m = /^(.+?)=(.+?),\\s*(.*)/.exec(s))) {\n      result[m[1]] = m[2]\n      s = m[3]\n    } else if ((m = /^(.+?)=\"(.*?[^\\\\])\"$/.exec(s))) {\n      result[m[1]] = m[2]\n      s = m[3]\n    } else if ((m = /^(.+?)=(.+?)$/.exec(s))) {\n      result[m[1]] = m[2]\n      s = m[3]\n    } else {\n      s = null\n    }\n  }\n  return result\n}\n\n/**\n * SASL serialization\n */\nfunction encodeDict (dict) {\n  var s = ''\n  for (var k in dict) {\n    var v = dict[k]\n    if (v) s += ',' + k + '=\"' + v + '\"'\n  }\n  return s.substr(1) // without first ','\n}\n\n/**\n * Right-justify a string,\n * eg. pad with 0s\n */\nfunction rjust (s, targetLen, padding) {\n  while (s.length < targetLen) {\n    s = padding + s\n  }\n  return s\n}\n\n/**\n * Generate a string of 8 digits\n * (number used once)\n */\nfunction generateNonce () {\n  var result = ''\n  for (var i = 0; i < 8; i++) {\n    result += String.fromCharCode(48 +\n      Math.ceil(Math.random() * 10))\n  }\n  return result\n}\n\nvar NS_XMPP_SASL = 'urn:ietf:params:xml:ns:xmpp-sasl'\n\n/**\n * @see http://tools.ietf.org/html/rfc2831\n * @see http://wiki.xmpp.org/web/SASLandDIGEST-MD5\n */\nfunction DigestMD5 (domain) {\n  this.nonce = generateNonce()\n  this.nonceCount = 0\n  this.authcid = null\n  this.actAs = null\n  this.realm = null\n  this.algorithm = 'md5-sess'\n  this.charset = 'utf-8'\n  this.qop = 'auth'\n  this.domain = domain\n}\n\nutil.inherits(DigestMD5, Mechanism)\n\nDigestMD5.prototype.name = 'DIGEST-MD5'\nDigestMD5.id = 'DIGEST-MD5'\n\nDigestMD5.prototype.manage = true\n\nDigestMD5.prototype.auth = function () {\n  return ''\n}\n\nDigestMD5.prototype.getNC = function () {\n  return rjust(this.nonceCount.toString(), 8, '0')\n}\n\nDigestMD5.prototype.responseValue = function (s, password) {\n  var dict = parseDict(s)\n  if (dict.realm) {\n    this.realm = dict.realm\n  }\n\n  var value\n  if (dict.nonce && dict.qop) {\n    this.nonceCount++\n    var a1 = md5(this.authcid + ':' +\n        this.realm + ':' +\n        password) + ':' +\n      dict.nonce + ':' +\n      this.cnonce\n\n    if (this.actAs) a1 += ':' + this.actAs\n\n    var a2 = 'AUTHENTICATE:' + this.digestUri\n    if ((dict.qop === 'auth-int') || (dict.qop === 'auth-conf')) {\n      a2 += ':00000000000000000000000000000000'\n    }\n\n    value = md5Hex(md5Hex(a1) + ':' +\n      dict.nonce + ':' +\n      ((this.nc) ? this.nc : this.getNC()) + ':' +\n      this.cnonce + ':' +\n      dict.qop + ':' +\n      md5Hex(a2))\n  }\n  return value\n}\n\nDigestMD5.prototype.serverChallenge = function () {\n  var dict = {}\n  dict.realm = this.domain\n  this.nonce = dict.nonce = generateNonce()\n  dict.qop = 'auth'\n  this.charset = dict.charset = 'utf-8'\n  dict.algorithm = 'md5-sess'\n  return new Buffer(encodeDict(dict)).toString('base64')\n}\n\n// Used on the server to check for auth!\nDigestMD5.prototype.checkResponse = function (s) {\n  var dict = parseDict(s)\n  this.authcid = this.username = dict.username\n\n  this.digestUri = dict['digest-uri']\n  if (dict.nonce !== this.nonce) return false\n  if (!dict.cnonce) return false\n\n  // dict['serv-type'] should be xmpp\n\n  if (dict.nc) {\n    this.nc = dict.nc\n  }\n  this.cnonce = dict.cnonce\n  if (this.charset !== dict.charset) return false\n\n  this.response = dict.response\n  return true\n}\n\nDigestMD5.prototype.manageAuth = function (stanza, server) {\n  if (stanza.is('auth', NS_XMPP_SASL)) {\n    // send initial challenge to client\n    var challenge = new Element('challenge', {\n      xmlns: NS_XMPP_SASL\n    }).t(this.serverChallenge())\n    server.send(challenge)\n  } else if (stanza.is('response', NS_XMPP_SASL) && stanza.getText() !== '') {\n    // response from client with challenge\n    var responseValid = this.checkResponse(new Buffer(stanza.getText(), 'base64'))\n    var self = this\n    if (responseValid) {\n      var user = {\n        'username': self.authcid\n      }\n      this.authenticate(user, function (err, user) {\n        // send final challenge and wait for response from user\n        if (self.response === self.responseValue(new Buffer(stanza.getText(), 'base64'), user.password)) {\n          var challenge = new Element('challenge', {\n            xmlns: NS_XMPP_SASL\n          })\n            .t(new Buffer('rspauth=ea40f60335c427b5527b84dbabcdfffd').toString('base64'))\n          server.send(challenge)\n          delete user.password\n          self.user = user\n        } else {\n          // no authenticated <response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>\n          self.failure(err)\n        }\n      })\n    } else {\n      // error if we are not able to authenticate the user\n      self.failure(new Error('Invalid response'))\n    }\n  } else if (stanza.is('response', NS_XMPP_SASL) && this.user) {\n    // here we are successfully authenticated and are able to call the callback\n    this.success(this.user)\n  } else if (stanza.is('response', NS_XMPP_SASL)) {\n    // client wants to skip mechanism steps\n    this.failure(new Error('Invalid response'))\n  }\n}\n\nDigestMD5.prototype.loginFailed = function (server) {\n  var jid = false\n  if (this.username) {\n    jid = new JID(this.username, server.serverdomain ? server.serverdomain.toString() : '')\n  }\n\n  server.emit('auth-failure', jid)\n  server.send(new Element('response', {\n    xmlns: NS_XMPP_SASL\n  }))\n}\n\nmodule.exports = DigestMD5\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/C2S/authentication/XOAuth2.js":"'use strict'\n\nvar util = require('util')\nvar Mechanism = require('./Mechanism')\n\n/**\n * @see https://developers.google.com/talk/jep_extensions/oauth\n */\nfunction XOAuth2 () {}\n\nutil.inherits(XOAuth2, Mechanism)\n\nXOAuth2.prototype.name = 'X-OAUTH2'\nXOAuth2.id = 'X-OAUTH2'\n\nXOAuth2.prototype.extractSasl = function (auth) {\n  var params = auth.split('\\x00')\n  var authRequest = {\n    'jid': params[1],\n    'oauth_token': params[2]\n  }\n  return authRequest\n}\n\nmodule.exports = XOAuth2\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-server/lib/C2S/authentication/Anonymous.js":"'use strict'\n\nvar crypto = require('crypto')\nvar util = require('util')\nvar Mechanism = require('./Mechanism')\n\nfunction Anonymous () {}\n\nutil.inherits(Anonymous, Mechanism)\n\nAnonymous.prototype.name = 'ANONYMOUS'\nAnonymous.id = 'ANONYMOUS'\n\nAnonymous.prototype.extractSasl = function () {\n  var user = crypto.randomBytes(16).toString('hex')\n  return { username: user }\n}\n\nmodule.exports = Anonymous\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-component/index.js":"'use strict'\n\nvar Component = require('./lib/Component')\nvar core = require('node-xmpp-core')\n\nmodule.exports = Component\nmodule.exports.Component = Component\n\ncore.exportCoreUtils(module.exports)\n","/home/travis/build/npmtest/node-npmtest-node-xmpp/node_modules/node-xmpp-component/lib/Component.js":"'use strict'\n\nvar util = require('util')\nvar crypto = require('crypto')\nvar EventEmitter = require('events').EventEmitter\nvar Connection = require('node-xmpp-core').Connection\nvar JID = require('node-xmpp-core').JID\nvar SRV = require('node-xmpp-core').SRV\nvar Element = require('node-xmpp-core').Element\n\n/**\n * opts:\n *   jid: String (required)\n *   password: String (required)\n *   host: String (required)\n *   port: Number (required)\n *   reconnect: Boolean (optional)\n */\nfunction Component (opts) {\n  EventEmitter.call(this)\n  var conn = this.connection = new Connection(opts)\n  this._addConnectionListeners()\n\n  if (typeof opts.jid === 'string') {\n    conn.jid = new JID(opts.jid)\n  } else {\n    conn.jid = opts.jid\n  }\n  conn.password = opts.password\n  conn.xmlns[''] = this.NS_COMPONENT\n  conn.xmlns['stream'] = this.NS_STREAM\n  conn.streamTo = this.connection.jid.domain\n\n  conn.listen({\n    socket: SRV.connect({\n      services: [],\n      domain: opts.host,\n      defaultPort: opts.port,\n      socket: opts.socket\n    })\n  })\n}\n\nutil.inherits(Component, EventEmitter)\n\nComponent.prototype.NS_COMPONENT = 'jabber:component:accept'\nComponent.prototype.NS_STREAM = 'http://etherx.jabber.org/streams'\n\nComponent.prototype.onStreamStart = function (streamAttrs) {\n  var digest = this._sha1Hex(streamAttrs.id + this.connection.password)\n  this.connection.send(new Element('handshake').t(digest))\n}\n\nComponent.prototype.onStanza = function (stanza) {\n  if (stanza.is('handshake')) {\n    this.emit('online')\n    return\n  }\n  this.emit('stanza', stanza)\n}\n\nComponent.prototype.send = function (stanza) {\n  // TODO node-xmpp-core Connection should probably do this\n  // and always add from attribute to outgoing stanzas if absent\n  if (!stanza.attrs.from) {\n    stanza.attrs.from = this.connection.jid.toString()\n  }\n  this.connection.send(stanza)\n}\n\nComponent.prototype.end = function () {\n  this.connection.end()\n}\n\nComponent.prototype._addConnectionListeners = function (con) {\n  con = con || this.connection\n  con.on('streamStart', this.onStreamStart.bind(this))\n  con.on('stanza', this.onStanza.bind(this))\n  con.on('drain', this.emit.bind(this, 'drain'))\n  con.on('data', this.emit.bind(this, 'data'))\n  con.on('end', this.emit.bind(this, 'end'))\n  con.on('close', this.emit.bind(this, 'close'))\n  con.on('error', this.emit.bind(this, 'error'))\n  con.on('connect', this.emit.bind(this, 'connect'))\n  con.on('reconnect', this.emit.bind(this, 'reconnect'))\n  con.on('disconnect', this.emit.bind(this, 'disconnect'))\n  con.on('disconnect', this.emit.bind(this, 'offline'))\n  if (con.startStream) {\n    con.on('connect', function () {\n      // Components start <stream:stream>, servers reply\n      con.startStream()\n    })\n  }\n}\n\nComponent.prototype._sha1Hex = function (s) {\n  var hash = crypto.createHash('sha1')\n  hash.update(s, 'binary')\n  return hash.digest('hex')\n}\n\nmodule.exports = Component\n"}